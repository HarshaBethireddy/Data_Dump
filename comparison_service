"""
JSON comparison service with deep difference analysis.

This service provides:
- Deep recursive JSON comparison
- Difference detection and reporting
- CSV export of comparison results
- Summary report generation
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

from refactored_codebase.config.settings import get_config
from refactored_codebase.core.constants import (
    COMPARISON_NULL_VALUE,
    COMPARISON_EMPTY_VALUE,
    COMPARISON_VALID_JSON,
    COMPARISON_INVALID_JSON,
    COMPARISON_ERROR,
    COMPARISON_FILE_SUFFIX,
    COMPARISON_SUMMARY_NAME
)
from refactored_codebase.core.exceptions import ComparisonError, JSONProcessingError
from refactored_codebase.core.models import (
    JSONDifference,
    FileComparisonResult,
    ComparisonSummary
)
from refactored_codebase.utils.file_handler import FileHandler, JSONHandler, CSVHandler
from refactored_codebase.utils.logger import get_logger, PerformanceLogger
from refactored_codebase.utils.validators import PathValidator


class JSONComparator:
    """
    Deep JSON comparison engine.

    Performs recursive comparison of JSON structures and identifies differences.
    """

    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or get_logger(__name__)
        self.difference_count = 0

    def compare_json_objects(
        self,
        obj1: Union[Dict, List, Any],
        obj2: Union[Dict, List, Any]
    ) -> List[JSONDifference]:
        """
        Public method to compare two JSON objects.

        Returns a list of JSONDifference objects.
        """
        self.difference_count = 0
        differences = self._compare_recursive(obj1, obj2, "")
        self.logger.debug(f"Total differences found: {len(differences)}")
        return differences

    def _compare_recursive(
        self,
        value1: Any,
        value2: Any,
        current_path: str
    ) -> List[JSONDifference]:
        """
        Recursively compare two values.

        current_path is the dot-separated path (no automatic 'root' prefix).
        """
        differences: List[JSONDifference] = []

        # Both None -> no difference
        if value1 is None and value2 is None:
            return differences

        # One is None
        if value1 is None and value2 is not None:
            differences.append(self._create_difference(
                current_path or "",
                COMPARISON_NULL_VALUE,
                self._safe_format(value2),
                "null_mismatch"
            ))
            return differences

        if value2 is None and value1 is not None:
            differences.append(self._create_difference(
                current_path or "",
                self._safe_format(value1),
                COMPARISON_NULL_VALUE,
                "null_mismatch"
            ))
            return differences

        # If either is a dict or list, prefer structural comparison:
        if isinstance(value1, dict) or isinstance(value2, dict):
            # If one is dict and the other not, type_mismatch
            if not (isinstance(value1, dict) and isinstance(value2, dict)):
                differences.append(self._create_difference(
                    current_path or "",
                    f"{type(value1).__name__}: {self._safe_format(value1)}",
                    f"{type(value2).__name__}: {self._safe_format(value2)}",
                    "type_mismatch"
                ))
                return differences

            # Both are dict -> compare keys recursively
            differences.extend(self._compare_dicts(value1, value2, current_path))
            return differences

        if isinstance(value1, list) or isinstance(value2, list):
            # If one is list and other not, type_mismatch
            if not (isinstance(value1, list) and isinstance(value2, list)):
                differences.append(self._create_difference(
                    current_path or "",
                    f"{type(value1).__name__}: {self._safe_format(value1)}",
                    f"{type(value2).__name__}: {self._safe_format(value2)}",
                    "type_mismatch"
                ))
                return differences

            # Both lists -> compare element-wise
            differences.extend(self._compare_lists(value1, value2, current_path))
            return differences

        # Primitive comparison (str, int, float, bool, etc.)
        if value1 != value2:
            differences.append(self._create_difference(
                current_path or "",
                self._safe_format(value1),
                self._safe_format(value2),
                "value_mismatch"
            ))

        return differences

    def _compare_dicts(
        self,
        dict1: Dict,
        dict2: Dict,
        parent_path: str
    ) -> List[JSONDifference]:
        """
        Compare two dictionaries recursively.
        """
        differences: List[JSONDifference] = []
        all_keys = set(dict1.keys()) | set(dict2.keys())

        for key in sorted(all_keys):
            # Build path: no leading dot, e.g. APPLICATION.DECISIONRSP.APPID
            key_path = f"{parent_path}.{key}" if parent_path else str(key)

            if key not in dict1:
                differences.append(self._create_difference(
                    key_path,
                    "KEY_MISSING",
                    self._safe_format(dict2[key]),
                    "missing_key_in_file1"
                ))
                continue

            if key not in dict2:
                differences.append(self._create_difference(
                    key_path,
                    self._safe_format(dict1[key]),
                    "KEY_MISSING",
                    "missing_key_in_file2"
                ))
                continue

            # Recurse for the value
            differences.extend(self._compare_recursive(dict1[key], dict2[key], key_path))

        return differences

    def _compare_lists(
        self,
        list1: List,
        list2: List,
        parent_path: str
    ) -> List[JSONDifference]:
        """
        Compare two lists recursively.

        Behavior:
        - If lengths differ, record a length_mismatch at parent_path + "[LENGTH]".
        - Then compare elements index by index and recurse.
        """
        differences: List[JSONDifference] = []

        if len(list1) != len(list2):
            differences.append(self._create_difference(
                f"{parent_path}[LENGTH]" if parent_path else "[LENGTH]",
                str(len(list1)),
                str(len(list2)),
                "length_mismatch"
            ))

        max_len = max(len(list1), len(list2))
        for i in range(max_len):
            index_path = f"{parent_path}[{i}]" if parent_path else f"[{i}]"

            if i >= len(list1):
                differences.append(self._create_difference(
                    index_path,
                    "INDEX_OUT_OF_RANGE",
                    self._safe_format(list2[i]),
                    "missing_index_in_file1"
                ))
                continue

            if i >= len(list2):
                differences.append(self._create_difference(
                    index_path,
                    self._safe_format(list1[i]),
                    "INDEX_OUT_OF_RANGE",
                    "missing_index_in_file2"
                ))
                continue

            differences.extend(self._compare_recursive(list1[i], list2[i], index_path))

        return differences

    def _create_difference(
        self,
        path: str,
        value1: str,
        value2: str,
        diff_type: str
    ) -> JSONDifference:
        """Create a JSONDifference object and increment counter."""
        self.difference_count += 1
        # Normalize empty path to empty string (so top-level keys show without "root")
        path = path or ""
        return JSONDifference(
            path=path,
            value_file1=value1,
            value_file2=value2,
            difference_type=diff_type
        )

    def _safe_format(self, value: Any, max_length: int = 400) -> str:
        """
        Safely format any value for display and CSV output.

        - None -> COMPARISON_NULL_VALUE
        - dict/list -> compact JSON string (truncated)
        - primitives -> str(value)
        """
        if value is None:
            return COMPARISON_NULL_VALUE

        try:
            if isinstance(value, (dict, list)):
                # compact but readable; limit size
                value_str = json.dumps(value, ensure_ascii=False, separators=(',', ':'), sort_keys=True)
            else:
                value_str = str(value)
        except Exception as e:
            value_str = f"<ERROR_FORMATTING: {str(e)}>"

        # single-line
        value_str = value_str.replace('\n', ' ').replace('\r', ' ').strip()

        if len(value_str) > max_length:
            return value_str[:max_length] + '...'

        return value_str


class ComparisonService:
    """
    Main service for comparing JSON files between folders.
    """

    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or get_logger(__name__)
        self.config = get_config()
        self.comparator = JSONComparator(self.logger)

    def _get_json_files(self, folder: Path) -> Dict[str, Path]:
        json_files = FileHandler.list_files(folder, "*.json")
        return {file.stem: file for file in json_files}

    def _load_and_parse_json(self, file_path: Path) -> Tuple[Any, str]:
        try:
            if file_path.stat().st_size == 0:
                return None, COMPARISON_EMPTY_VALUE

            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                parsed = json.loads(content)

            self.logger.debug(f"Loaded JSON from {file_path.name}, type: {type(parsed).__name__}")
            return parsed, COMPARISON_VALID_JSON

        except json.JSONDecodeError as e:
            self.logger.error(f"Invalid JSON in {file_path.name}: {e}")
            return None, f"{COMPARISON_INVALID_JSON}: {str(e)}"
        except Exception as e:
            self.logger.error(f"Error loading {file_path.name}: {e}")
            return None, f"ERROR: {str(e)}"

    def _compare_single_file(
        self,
        file1: Path,
        file2: Path,
        file_name: str
    ) -> FileComparisonResult:
        try:
            self.logger.debug(f"Comparing {file_name}...")

            json1, status1 = self._load_and_parse_json(file1)
            json2, status2 = self._load_and_parse_json(file2)

            # Handle empty or invalid files
            if status1 == COMPARISON_EMPTY_VALUE and status2 == COMPARISON_EMPTY_VALUE:
                return FileComparisonResult(
                    file_name=file_name,
                    has_differences=False,
                    differences=[],
                    file1_status=status1,
                    file2_status=status2
                )

            if status1 == COMPARISON_EMPTY_VALUE:
                return FileComparisonResult(
                    file_name=file_name,
                    has_differences=True,
                    differences=[JSONDifference(
                        path="FILE_STATUS",
                        value_file1=COMPARISON_EMPTY_VALUE,
                        value_file2="HAS_CONTENT",
                        difference_type="file_empty"
                    )],
                    file1_status=status1,
                    file2_status=status2
                )

            if status2 == COMPARISON_EMPTY_VALUE:
                return FileComparisonResult(
                    file_name=file_name,
                    has_differences=True,
                    differences=[JSONDifference(
                        path="FILE_STATUS",
                        value_file1="HAS_CONTENT",
                        value_file2=COMPARISON_EMPTY_VALUE,
                        difference_type="file_empty"
                    )],
                    file1_status=status1,
                    file2_status=status2
                )

            if not status1.startswith(COMPARISON_VALID_JSON):
                return FileComparisonResult(
                    file_name=file_name,
                    has_differences=True,
                    differences=[JSONDifference(
                        path="JSON_PARSE_ERROR",
                        value_file1=status1,
                        value_file2=status2,
                        difference_type="parse_error"
                    )],
                    file1_status=status1,
                    file2_status=status2
                )

            if not status2.startswith(COMPARISON_VALID_JSON):
                return FileComparisonResult(
                    file_name=file_name,
                    has_differences=True,
                    differences=[JSONDifference(
                        path="JSON_PARSE_ERROR",
                        value_file1=status1,
                        value_file2=status2,
                        difference_type="parse_error"
                    )],
                    file1_status=status1,
                    file2_status=status2
                )

            # Both files are valid - perform deep comparison
            self.logger.debug(f"Performing deep comparison of {file_name}")
            differences = self.comparator.compare_json_objects(json1, json2)

            self.logger.info(f"File {file_name}: Found {len(differences)} differences")

            return FileComparisonResult(
                file_name=file_name,
                has_differences=len(differences) > 0,
                differences=differences,
                file1_status=status1,
                file2_status=status2
            )

        except Exception as e:
            self.logger.error(f"Error comparing {file_name}: {e}", exc_info=True)
            return FileComparisonResult(
                file_name=file_name,
                has_differences=True,
                differences=[JSONDifference(
                    path=COMPARISON_ERROR,
                    value_file1=str(e),
                    value_file2=str(e),
                    difference_type="comparison_error"
                )],
                file1_status=COMPARISON_ERROR,
                file2_status=COMPARISON_ERROR
            )

    def _save_comparison_csv(
        self,
        result: FileComparisonResult,
        output_folder: Path
    ) -> Path:
        """
        Save comparison result to CSV file. Adds File Name column so merged CSVs
        are explicit about source file.
        """
        import pandas as pd

        csv_file = output_folder / f"{result.file_name}{COMPARISON_FILE_SUFFIX}.csv"

        data = []
        for diff in result.differences:
            data.append({
                'File Name': result.file_name,
                'Path': diff.path,
                'Value in File 1': diff.value_file1,
                'Value in File 2': diff.value_file2,
                'Comparison Result': 'FALSE'  # difference rows are false
            })

        if data:
            df = pd.DataFrame(data)
            CSVHandler.write_dataframe_to_csv(df, csv_file)
            self.logger.debug(f"Saved {len(data)} differences to {csv_file.name}")
        else:
            df = pd.DataFrame(columns=['File Name', 'Path', 'Value in File 1', 'Value in File 2', 'Comparison Result'])
            CSVHandler.write_dataframe_to_csv(df, csv_file)

        return csv_file

    def _generate_summary_report(
        self,
        summary: ComparisonSummary,
        output_folder: Path
    ) -> None:
        summary_file = output_folder / COMPARISON_SUMMARY_NAME

        lines = [
            "JSON COMPARISON SUMMARY REPORT",
            "=" * 80,
            "",
            f"Comparison: {summary.folder1_name} vs {summary.folder2_name}",
            f"Generated: {summary.timestamp.strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "STATISTICS:",
            f"  Total common files: {summary.total_common_files}",
            f"  Files with differences: {summary.files_with_differences}",
            f"  Identical files: {summary.files_identical}",
            f"  Files only in {summary.folder1_name}: {len(summary.only_in_folder1)}",
            f"  Files only in {summary.folder2_name}: {len(summary.only_in_folder2)}",
            ""
        ]

        if summary.only_in_folder1:
            lines.append(f"FILES ONLY IN {summary.folder1_name}:")
            for filename in sorted(summary.only_in_folder1):
                lines.append(f"  - {filename}")
            lines.append("")

        if summary.only_in_folder2:
            lines.append(f"FILES ONLY IN {summary.folder2_name}:")
            for filename in sorted(summary.only_in_folder2):
                lines.append(f"  - {filename}")
            lines.append("")

        if summary.comparison_results:
            lines.append("FILES WITH DIFFERENCES:")
            for result in summary.comparison_results:
                if result.has_differences:
                    # show number of difference rows found
                    lines.append(
                        f"  - {result.file_name}: {len(result.differences)} differences"
                    )

        if summary.files_identical == summary.total_common_files:
            lines.append("\n✓ All common files are identical! 🎉")

        FileHandler.write_text_file(summary_file, "\n".join(lines))
        self.logger.info(f"Summary report saved: {summary_file}")

    def compare_folders(
        self,
        folder1: Path,
        folder2: Path,
        folder1_name: str,
        folder2_name: str,
        output_folder: Optional[Path] = None
    ) -> ComparisonSummary:
        try:
            with PerformanceLogger(self.logger, f"Compare {folder1_name} vs {folder2_name}"):
                PathValidator.validate_directory_exists(folder1, f"Folder '{folder1_name}'")
                PathValidator.validate_directory_exists(folder2, f"Folder '{folder2_name}'")

                if output_folder is None:
                    output_folder = (
                        self.config.paths.output_comparisons /
                        f"{folder1_name}_vs_{folder2_name}"
                    )

                FileHandler.ensure_directory(output_folder)

                files1 = self._get_json_files(folder1)
                files2 = self._get_json_files(folder2)

                common_files = set(files1.keys()) & set(files2.keys())
                only_in_folder1 = set(files1.keys()) - set(files2.keys())
                only_in_folder2 = set(files2.keys()) - set(files1.keys())

                self.logger.info(
                    f"Found {len(common_files)} common files, "
                    f"{len(only_in_folder1)} only in {folder1_name}, "
                    f"{len(only_in_folder2)} only in {folder2_name}"
                )

                comparison_results: List[FileComparisonResult] = []
                files_with_differences = 0

                for file_name in sorted(common_files):
                    result = self._compare_single_file(
                        file1=files1[file_name],
                        file2=files2[file_name],
                        file_name=file_name
                    )

                    comparison_results.append(result)

                    if result.has_differences:
                        files_with_differences += 1
                        # Save differences to CSV (one CSV per file)
                        self._save_comparison_csv(result, output_folder)
                    else:
                        self.logger.debug(f"No differences in {file_name}")

                summary = ComparisonSummary(
                    folder1_name=folder1_name,
                    folder2_name=folder2_name,
                    total_common_files=len(common_files),
                    files_with_differences=files_with_differences,
                    files_identical=len(common_files) - files_with_differences,
                    only_in_folder1=sorted(only_in_folder1),
                    only_in_folder2=sorted(only_in_folder2),
                    comparison_results=comparison_results,
                    timestamp=datetime.now()
                )

                self._generate_summary_report(summary, output_folder)

                self.logger.info(
                    f"Comparison completed: {files_with_differences}/{len(common_files)} "
                    f"files have differences"
                )

                return summary

        except Exception as e:
            if isinstance(e, ComparisonError):
                raise
            raise ComparisonError(
                "Failed to compare folders",
                file1=str(folder1),
                file2=str(folder2),
                original_error=e
            )
