package com.harsha.extractor;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.openqa.selenium.*;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.Select;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * ULTRA-OPTIMIZED Bureau Comparison - Maximum Performance
 *
 * Strategy: Smart browser management + Maximum parallelism + Output correctness
 * guaranteed
 * Expected: 40 hours -> 5-8 hours (5-8x improvement)
 */
public class UltraOptimizedBureauComparison {

    private static final String BASE_URL = "http://usaqwblbcus30.us.experian.eeca:8080/WebEngine/";
    private static final String USERNAME = "Harsh";
    private static final String PASSWORD = "Friday@0123!";
    private static final String BASE_PRE_FOLDER = "C:/Users/C24692E/Downloads/";
    private static final String BASE_POST_FOLDER = "C:/Users/C24692E/Downloads/";
    private static final String BASE_OUTPUT_DIRECTORY = "C:\\Users\\C24692E\\Downloads\\bureau_comparisons";
    private static final DateTimeFormatter RUN_DIR_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss_SSS");

    // OPTIMIZED: Smart browser pool - start conservative, can increase if stable
    private static final int BROWSER_POOL_SIZE = 10; // Start with 10, monitor and increase
    private static final int MAX_LOGIN_RETRIES = 3;
    private static final String CHECKPOINT_FILE = "processing_checkpoint.dat";
    private static final String ADMIN_GROUP = "Administrators";

    private static final Map<String, CategoryConfig> CATEGORY_CONFIGS = new HashMap<>();
    static {
        CATEGORY_CONFIGS.put("ACQ", new CategoryConfig(new String[] { "View Only", "Credit Full", "All" }));
        CATEGORY_CONFIGS.put("CLI", new CategoryConfig(new String[] { "View Only", "CLI Credit Full", "All" }));
        CATEGORY_CONFIGS.put("PRQ", new CategoryConfig(new String[] { "View Only", "PreQual Credit Full", "All" }));
        CATEGORY_CONFIGS.put("PREQUAL", new CategoryConfig(new String[] { "View Only", "PreQual Credit Full", "All" }));
        CATEGORY_CONFIGS.put("Prequal", new CategoryConfig(new String[] { "View Only", "PreQual Credit Full", "All" }));
        CATEGORY_CONFIGS.put("PreQual", new CategoryConfig(new String[] { "View Only", "PreQual Credit Full", "All" }));
    }

    private static final List<String> APPID_KEYS = Arrays.asList(
            "APPID", "AppID", "AppId", "appId", "appid", "APP_ID", "app_id", "APP-ID", "app-id");
    private static final List<String> ID_KEYS = Arrays.asList(
            "id", "ID", "Id", "value", "appId", "APPID");

    // Synchronized login to prevent conflicts
    private static final Object LOGIN_LOCK = new Object();
    private static final AtomicInteger ACTIVE_BROWSERS = new AtomicInteger(0);

    static class CategoryConfig {
        String[] menuPath;

        CategoryConfig(String... menuPath) {
            this.menuPath = menuPath;
        }
    }

    static class ApplicationData {
        String fileName;
        String preAppId;
        String postAppId;
        String category;
        String uniqueId;

        ApplicationData(String fileName, String preAppId, String postAppId) {
            this.fileName = fileName;
            this.preAppId = preAppId;
            this.postAppId = postAppId;
            this.category = determineCategory(fileName);
            this.uniqueId = fileName + "_" + preAppId + "_" + postAppId;
        }

        boolean isValid() {
            return fileName != null && !fileName.trim().isEmpty() &&
                    preAppId != null && !preAppId.trim().isEmpty() &&
                    postAppId != null && !postAppId.trim().isEmpty();
        }

        private String determineCategory(String fileName) {
            if (fileName == null)
                return "UNKNOWN";
            String upper = fileName.toUpperCase(Locale.ROOT);
            if (upper.contains("CLI"))
                return "CLI";
            if (upper.contains("PRQ") || upper.contains("PREQUAL"))
                return "PRQ";
            if (upper.contains("ACQ"))
                return "ACQ";
            return "ACQ";
        }
    }

    static class BrowserInstance {
        WebDriver driver;
        WebDriverWait wait;
        int instanceId;
        boolean loggedIn;
        String currentCategory;
        long lastUsedTime;

        BrowserInstance(int instanceId) {
            this.instanceId = instanceId;
            ChromeOptions options = new ChromeOptions();
            options.addArguments("--start-maximized");
            options.addArguments("--disable-blink-features=AutomationControlled");
            options.addArguments("--disable-gpu");
            options.addArguments("--no-sandbox");
            options.addArguments("--disable-dev-shm-usage");
            options.setPageLoadStrategy(PageLoadStrategy.NORMAL); // NORMAL for stability

            this.driver = new ChromeDriver(options);
            this.wait = new WebDriverWait(driver, Duration.ofSeconds(50));
            this.loggedIn = false;
            this.lastUsedTime = System.currentTimeMillis();
        }

        void updateLastUsed() {
            this.lastUsedTime = System.currentTimeMillis();
        }

        void cleanup() {
            try {
                if (driver != null)
                    driver.quit();
            } catch (Exception e) {
                System.err.println("‚ö†Ô∏è Error closing browser " + instanceId);
            }
        }
    }

    static class BrowserPool {
        private final BlockingQueue<BrowserInstance> available;
        private final List<BrowserInstance> allBrowsers;
        private final ExecutorService initExecutor;

        BrowserPool(int size) {
            this.available = new LinkedBlockingQueue<>();
            this.allBrowsers = new CopyOnWriteArrayList<>();
            this.initExecutor = Executors.newFixedThreadPool(3); // Init 3 at a time

            System.out.println("üöÄ Initializing " + size + " browsers (3 at a time for stability)...");

            CountDownLatch latch = new CountDownLatch(size);
            for (int i = 0; i < size; i++) {
                final int id = i;
                initExecutor.submit(() -> {
                    try {
                        Thread.sleep(id * 2000L); // Stagger 2 seconds apart
                        BrowserInstance browser = new BrowserInstance(id);

                        // Immediate login during initialization
                        synchronized (LOGIN_LOCK) {
                            if (performLoginInternal(browser)) {
                                browser.loggedIn = true;
                                allBrowsers.add(browser);
                                available.offer(browser);
                                ACTIVE_BROWSERS.incrementAndGet();
                                System.out.println("‚úÖ Browser " + id + " ready and authenticated");
                            } else {
                                System.err.println("‚ùå Browser " + id + " failed to authenticate");
                                browser.cleanup();
                            }
                        }
                    } catch (Exception e) {
                        System.err.println("‚ùå Browser " + id + " init failed: " + e.getMessage());
                    } finally {
                        latch.countDown();
                    }
                });
            }

            try {
                latch.await(10, TimeUnit.MINUTES);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }

            initExecutor.shutdown();
            System.out.println("‚úÖ Browser pool ready: " + ACTIVE_BROWSERS.get() + "/" + size + " active");
        }

        BrowserInstance acquire() throws InterruptedException {
            BrowserInstance browser = available.poll(120, TimeUnit.SECONDS);
            if (browser != null) {
                browser.updateLastUsed();
            }
            return browser;
        }

        void release(BrowserInstance browser) {
            if (browser != null) {
                browser.updateLastUsed();
                available.offer(browser);
            }
        }

        void shutdown() {
            System.out.println("üõë Shutting down browser pool...");
            allBrowsers.forEach(BrowserInstance::cleanup);
            available.clear();
            allBrowsers.clear();
        }
    }

    static class ProgressTracker {
        private final AtomicInteger completed = new AtomicInteger(0);
        private final AtomicInteger failed = new AtomicInteger(0);
        private final int total;
        private final Set<String> processedIds = ConcurrentHashMap.newKeySet();
        private final String checkpointPath;
        private final long startTime = System.currentTimeMillis();

        ProgressTracker(int total, String outputFolder) {
            this.total = total;
            this.checkpointPath = outputFolder + File.separator + CHECKPOINT_FILE;
            loadCheckpoint();
        }

        void loadCheckpoint() {
            File checkpoint = new File(checkpointPath);
            if (checkpoint.exists()) {
                try (BufferedReader reader = new BufferedReader(new FileReader(checkpoint))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        processedIds.add(line.trim());
                    }
                    completed.set(processedIds.size());
                    System.out.println("üì• Checkpoint loaded: " + processedIds.size() + " already completed");
                } catch (IOException e) {
                    System.err.println("‚ö†Ô∏è Checkpoint load failed: " + e.getMessage());
                }
            }
        }

        boolean isProcessed(String id) {
            return processedIds.contains(id);
        }

        void markCompleted(String id, boolean success) {
            if (success) {
                completed.incrementAndGet();
                processedIds.add(id);
                saveCheckpoint(id);
            } else {
                failed.incrementAndGet();
            }

            int done = completed.get() + failed.get();
            if (done % 10 == 0 || done == total) {
                printProgress();
            }
        }

        void saveCheckpoint(String id) {
            try (FileWriter writer = new FileWriter(checkpointPath, true)) {
                writer.write(id + "\n");
            } catch (IOException ignored) {
            }
        }

        void printProgress() {
            int done = completed.get() + failed.get();
            double percent = (done * 100.0) / total;
            long elapsed = System.currentTimeMillis() - startTime;
            double avgTime = done > 0 ? elapsed / (double) done : 0;
            int remaining = total - done;
            long eta = (long) (remaining * avgTime);

            System.out.printf("üìä Progress: %d/%d (%.1f%%) | ‚úÖ %d | ‚ùå %d | ‚è±Ô∏è ETA: %s | üåê Browsers: %d%n",
                    done, total, percent, completed.get(), failed.get(), formatDuration(eta), ACTIVE_BROWSERS.get());
        }

        void printFinal() {
            long elapsed = System.currentTimeMillis() - startTime;
            System.out.println("\n" + "‚ïê".repeat(70));
            System.out.println("üìà FINAL REPORT");
            System.out.println("‚ïê".repeat(70));
            System.out.println("Total: " + total);
            System.out.println("‚úÖ Success: " + completed.get());
            System.out.println("‚ùå Failed: " + failed.get());
            System.out.println("‚è±Ô∏è Time: " + formatDuration(elapsed));
            System.out.println("‚ö° Speed: " + String.format("%.2f items/sec", completed.get() * 1000.0 / elapsed));
            System.out.println("‚ïê".repeat(70));
        }

        private String formatDuration(long millis) {
            long hrs = millis / 3600000;
            long mins = (millis % 3600000) / 60000;
            long secs = (millis % 60000) / 1000;
            return String.format("%02d:%02d:%02d", hrs, mins, secs);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BrowserPool browserPool = null;
        ExecutorService executor = null;

        try {

            System.out.print("Enter PRE folder name (in Downloads): ");
            String preFolderName = scanner.nextLine().trim();
            String preFolderPath = BASE_PRE_FOLDER + preFolderName;

            System.out.print("Enter POST folder name (in Downloads): ");
            String postFolderName = scanner.nextLine().trim();
            String postFolderPath = BASE_POST_FOLDER + postFolderName;

            String outputFolder = BASE_OUTPUT_DIRECTORY + "\\comparison_" +
                    LocalDateTime.now().format(RUN_DIR_FORMATTER);

            System.out.println("\n=== Step 1: Comparing APP IDs ===");
            String excelFilePath = compareAppIDsSingleFile(preFolderPath, postFolderPath, outputFolder);

            if (excelFilePath == null) {
                System.out.println("‚ùå No Excel generated. Exiting.");
                return;
            }

            System.out.println("\n=== Step 2: Initializing Browser Pool ===");
            browserPool = new BrowserPool(BROWSER_POOL_SIZE);

            if (ACTIVE_BROWSERS.get() == 0) {
                System.out.println("‚ùå No browsers could authenticate. Check credentials and server.");
                return;
            }

            System.out.println("\n=== Step 3: Processing Applications ===");
            List<ApplicationData> applications = readUnifiedExcelFile(excelFilePath);
            System.out.println("üìä Total applications: " + applications.size());

            ProgressTracker tracker = new ProgressTracker(applications.size(), outputFolder);

            List<ApplicationData> pending = applications.stream()
                    .filter(app -> !tracker.isProcessed(app.uniqueId))
                    .collect(Collectors.toList());

            System.out.println("‚è≠Ô∏è Remaining: " + pending.size());

            if (pending.isEmpty()) {
                System.out.println("‚úÖ All already processed!");
                tracker.printFinal();
                return;
            }

            // Process in parallel with work-stealing pool
            executor = Executors.newWorkStealingPool(BROWSER_POOL_SIZE * 2);

            final BrowserPool finalPool = browserPool;
            final ExecutorService finalExecutor = executor;
            final ProgressTracker finalTracker = tracker;
            final String finalOutputFolder = outputFolder;
            ConcurrentLinkedQueue<String> reports = new ConcurrentLinkedQueue<>();

            List<CompletableFuture<Void>> futures = pending.stream()
                    .map(app -> CompletableFuture.runAsync(() -> {
                        BrowserInstance browser = null;
                        try {
                            browser = finalPool.acquire();
                            if (browser == null) {
                                throw new RuntimeException("Could not acquire browser");
                            }

                            String report = processApplication(browser, app, finalOutputFolder);
                            if (report != null) {
                                reports.add(report);
                                finalTracker.markCompleted(app.uniqueId, true);
                            } else {
                                finalTracker.markCompleted(app.uniqueId, false);
                            }

                        } catch (Exception e) {
                            System.err.println("‚ùå Error: " + app.fileName + " - " + e.getMessage());
                            finalTracker.markCompleted(app.uniqueId, false);
                        } finally {
                            if (browser != null) {
                                finalPool.release(browser);
                            }
                        }
                    }, finalExecutor))
                    .collect(Collectors.toList());

            // Wait for all to complete
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get();

            // Generate master report
            System.out.println("\nüìù Generating master report...");
            generateMasterReport(reports, outputFolder, applications.size());

            tracker.printFinal();
            System.out.println("\n‚úÖ Processing complete!");
            System.out.println("üìÅ Output: " + outputFolder);

        } catch (Exception e) {
            System.err.println("‚ùå Fatal error: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (executor != null) {
                executor.shutdown();
                try {
                    executor.awaitTermination(60, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    executor.shutdownNow();
                }
            }
            if (browserPool != null) {
                browserPool.shutdown();
            }
            scanner.close();
        }
    }

    private static String processApplication(BrowserInstance browser, ApplicationData app, String baseOutputFolder) {
        try {
            String categoryFolder = baseOutputFolder + File.separator + app.category + File.separator;
            Files.createDirectories(Paths.get(categoryFolder));

            // Ensure category navigation
            ensureCategoryNavigation(browser, app.category);

            // Extract PRE
            String preFile = categoryFolder + app.fileName + "_PRE_" + app.preAppId + ".txt";
            if (!extractBureauData(browser, app.preAppId, preFile, "PRE")) {
                return null;
            }

            navigateBackToSearch(browser);

            // Extract POST
            String postFile = categoryFolder + app.fileName + "_POST_" + app.postAppId + ".txt";
            if (!extractBureauData(browser, app.postAppId, postFile, "POST")) {
                return null;
            }

            navigateBackToSearch(browser);

            // Compare
            return compareFiles(preFile, postFile, app);

        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Process failed for " + app.fileName + ": " + e.getMessage());
            return null;
        }
    }

    private static void ensureCategoryNavigation(BrowserInstance browser, String category) throws Exception {
        if (category.equals(browser.currentCategory)) {
            return; // Already there
        }

        CategoryConfig config = CATEGORY_CONFIGS.get(category);
        if (config == null) {
            throw new Exception("Unknown category: " + category);
        }

        navigateToSearchScreen(browser.driver, browser.wait, config);
        browser.currentCategory = category;
    }

    private static boolean extractBureauData(BrowserInstance browser, String appId,
            String outputPath, String type) {
        try {
            // Fill and search (KEEP ORIGINAL TIMING)
            fillApplicationIdAndSearch(browser.driver, browser.wait, appId);

            // Click application link
            WebElement openLink = browser.wait.until(ExpectedConditions.elementToBeClickable(
                    By.xpath("//table[@id='datagrid']//td//div//center//a")));
            openLink.click();
            sleepSeconds(3);

            // Click View Bureau
            WebElement viewBtn = browser.wait.until(ExpectedConditions.elementToBeClickable(
                    By.xpath("//button[.='View Bureau']")));
            viewBtn.click();
            sleepSeconds(1);

            // Extract from popup (EXACT ORIGINAL LOGIC)
            String mainWindow = browser.driver.getWindowHandle();
            sleepSeconds(3);

            Set<String> windows = browser.driver.getWindowHandles();
            String popupWindow = null;
            for (String w : windows) {
                if (!w.equals(mainWindow)) {
                    popupWindow = w;
                    break;
                }
            }

            if (popupWindow == null) {
                throw new RuntimeException("Popup not found");
            }

            browser.driver.switchTo().window(popupWindow);
            sleepSeconds(3);

            StringBuilder bureauData = new StringBuilder();
            bureauData.append("===== BUREAU DATA EXTRACTION =====\n");
            bureauData.append("Type: ").append(type).append("\n");
            bureauData.append("Application ID: ").append(appId).append("\n");
            bureauData.append("Extraction Time: ").append(LocalDateTime.now()).append("\n");
            bureauData.append("==================================\n\n");

            List<WebElement> links = findRequestResponseLinks(browser.driver, browser.wait);

            for (int i = 0; i < links.size(); i++) {
                links = findRequestResponseLinks(browser.driver, browser.wait);

                if (i < links.size()) {
                    WebElement link = links.get(i);
                    String bureauKey = link.getAttribute("bureaukey");
                    String linkType = link.getAttribute("type");

                    bureauData.append("\n").append("=".repeat(50)).append("\n");
                    bureauData.append("Bureau: ").append(bureauKey != null ? bureauKey : "Unknown").append("\n");
                    bureauData.append("Type: ").append(linkType != null ? linkType : "Unknown").append("\n");
                    bureauData.append("=".repeat(50)).append("\n");

                    ((JavascriptExecutor) browser.driver).executeScript("arguments[0].click();", link);
                    sleepSeconds(2);

                    Set<String> currentWindows = browser.driver.getWindowHandles();
                    String dataWindow = null;
                    for (String w : currentWindows) {
                        if (!w.equals(mainWindow) && !w.equals(popupWindow)) {
                            dataWindow = w;
                            break;
                        }
                    }

                    if (dataWindow != null) {
                        browser.driver.switchTo().window(dataWindow);

                        try {
                            WebElement preElement = browser.wait.until(
                                    ExpectedConditions.presenceOfElementLocated(By.tagName("pre")));
                            bureauData.append(preElement.getText()).append("\n");
                        } catch (Exception e) {
                            String bodyText = browser.driver.findElement(By.tagName("body")).getText();
                            bureauData.append(bodyText).append("\n");
                        }

                        browser.driver.close();
                        browser.driver.switchTo().window(popupWindow);
                    }

                    sleepSeconds(1);
                }
            }

            // Save file
            Files.writeString(Paths.get(outputPath), bureauData.toString(), StandardCharsets.UTF_8);

            browser.driver.close();
            browser.driver.switchTo().window(mainWindow);

            return true;

        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Extract failed for " + appId + ": " + e.getMessage());

            // Try to recover window state
            try {
                String mainWindow = browser.driver.getWindowHandle();
                for (String w : browser.driver.getWindowHandles()) {
                    if (!w.equals(mainWindow)) {
                        try {
                            browser.driver.switchTo().window(w);
                            browser.driver.close();
                        } catch (Exception ignore) {
                        }
                    }
                }
                browser.driver.switchTo().window(mainWindow);
            } catch (Exception ignore) {
            }

            return false;
        }
    }

    private static void fillApplicationIdAndSearch(WebDriver driver, WebDriverWait wait, String appId) {
        try {
            wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("txt-appid")));
            sleepSeconds(2);

            WebElement appIdField = wait.until(ExpectedConditions.elementToBeClickable(By.id("txt-appid")));
            ((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView(true);", appIdField);
            appIdField.click();

            appIdField.sendKeys(Keys.CONTROL + "a");
            appIdField.sendKeys(Keys.DELETE);
            sleepSeconds(1);

            for (char c : appId.toCharArray()) {
                appIdField.sendKeys(String.valueOf(c));
                try {
                    Thread.sleep(50);
                } catch (InterruptedException ignored) {
                }
            }

            wait.until(ExpectedConditions.attributeToBe(By.id("txt-appid"), "value", appId));
            sleepSeconds(1);

            WebElement searchBtn = wait.until(ExpectedConditions.elementToBeClickable(By.id("btn-search")));
            searchBtn.click();
            // sleepSeconds(3);

        } catch (Exception e) {
            throw new RuntimeException("Search failed for: " + appId, e);
        }
    }

    private static void navigateBackToSearch(BrowserInstance browser) {
        try {
            WebElement closeBtn = browser.wait.until(ExpectedConditions.elementToBeClickable(
                    By.xpath("//button[.='Close']")));
            closeBtn.click();
            // sleepSeconds(2);

            handleConfirmationModal(browser.driver, browser.wait);

            browser.wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("txt-appid")));
            // sleepSeconds(2);

        } catch (Exception e) {
            throw new RuntimeException("Navigate back failed", e);
        }
    }

    private static void handleConfirmationModal(WebDriver driver, WebDriverWait wait) {
        try {
            wait.until(ExpectedConditions.visibilityOfElementLocated(By.cssSelector(".wicket-modal")));
            WebElement okBtn = wait.until(ExpectedConditions.elementToBeClickable(By.xpath("//*[@name='ok']")));
            okBtn.click();
            sleepSeconds(1);
        } catch (Exception e) {
            try {
                WebElement okBtn = wait.until(ExpectedConditions.elementToBeClickable(
                        By.xpath("//input[@type='button' and @value='OK']")));
                okBtn.click();
                try { Thread.sleep(500); } catch (InterruptedException ignored) {}
            } catch (Exception ignored) {
            }
        }
    }

    private static List<WebElement> findRequestResponseLinks(WebDriver driver, WebDriverWait wait) {
        List<WebElement> result = new ArrayList<>();

        try {
            wait.until(ExpectedConditions.presenceOfElementLocated(By.className("jstree")));
            expandAllJsTreeNodes(driver, wait);

            List<WebElement> rawLinks = driver.findElements(By.xpath("//a[@raw]"));
            for (WebElement link : rawLinks) {
                String type = link.getAttribute("type");
                if ("request".equals(type) || "response".equals(type)) {
                    result.add(link);
                }
            }
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Error finding links: " + e.getMessage());
        }

        return result;
    }

    private static void expandAllJsTreeNodes(WebDriver driver, WebDriverWait wait) {
        wait.until(ExpectedConditions.presenceOfElementLocated(By.cssSelector(".jstree")));
        JavascriptExecutor js = (JavascriptExecutor) driver;

        try {
            Object success = js.executeScript(
                    "try {" +
                            "  if (window.$ && $('.jstree').length && $('.jstree').jstree) {" +
                            "    var inst = $('.jstree').jstree(true) || $('.jstree').jstree(); " +
                            "    if (inst && inst.open_all) { inst.open_all(); return true; }" +
                            "  }" +
                            "} catch(e) {}" +
                            "return false;");

            if (Boolean.TRUE.equals(success)) {
                try {
                    wait.until(d -> driver.findElements(By.cssSelector(".jstree .jstree-loading")).isEmpty());
                } catch (TimeoutException ignored) {
                }
                return;
            }
        } catch (Exception ignored) {
        }

        int safety = 0;
        while (safety++ < 50) {
            List<WebElement> closed = driver.findElements(
                    By.cssSelector(".jstree li.jstree-closed > i.jstree-ocl"));

            if (closed.isEmpty())
                break;

            for (WebElement toggler : closed) {
                try {
                    toggler.click();
                    Thread.sleep(150);
                } catch (Exception e) {
                    try {
                        js.executeScript("arguments[0].click();", toggler);
                        Thread.sleep(150);
                    } catch (Exception ignored) {
                    }
                }
            }
        }
    }

    private static boolean performLoginInternal(BrowserInstance browser) {
        try {
            browser.driver.get(BASE_URL);
            // sleepSeconds(3);

            WebElement usernameInput = browser.wait
                    .until(ExpectedConditions.visibilityOfElementLocated(By.id("idToken1")));
            WebElement passwordInput = browser.wait
                    .until(ExpectedConditions.visibilityOfElementLocated(By.id("idToken2")));
            WebElement loginButton = browser.wait
                    .until(ExpectedConditions.elementToBeClickable(By.id("loginButton_0")));

            usernameInput.clear();
            usernameInput.sendKeys(USERNAME);
            passwordInput.clear();
            passwordInput.sendKeys(PASSWORD);
            loginButton.click();

            // sleepSeconds(3);

            // Select admin group
            WebElement groupsSelectEl = browser.wait
                    .until(ExpectedConditions.visibilityOfElementLocated(By.id("groups")));
            Select groupsSelect = new Select(groupsSelectEl);
            groupsSelect.selectByVisibleText(ADMIN_GROUP);

            WebElement submitBtn = browser.wait.until(ExpectedConditions.elementToBeClickable(By.id("id2")));
            submitBtn.click();

            // sleepSeconds(3);

            browser.wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("menu-wrapper")));
            browser.wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("menu")));

            return true;

        } catch (Exception e) {
            System.err.println("Login failed for browser " + browser.instanceId + ": " + e.getMessage());
            return false;
        }
    }

    private static void navigateToSearchScreen(WebDriver driver, WebDriverWait wait, CategoryConfig config) {
        try {
            openMenuAndClick(driver, wait, config.menuPath);
            // sleepSeconds(3);
        } catch (Exception e) {
            throw new RuntimeException("Navigation failed: " + e.getMessage(), e);
        }
    }

    private static void openMenuAndClick(WebDriver driver, WebDriverWait wait, String... labels) {
        if (labels == null || labels.length == 0) {
            throw new IllegalArgumentException("Labels required");
        }

        Actions actions = new Actions(driver);
        JavascriptExecutor js = (JavascriptExecutor) driver;
        WebElement scope = wait.until(ExpectedConditions.presenceOfElementLocated(By.cssSelector("ul#menu")));

        for (int i = 0; i < labels.length; i++) {
            String label = labels[i].trim().replaceAll("\\s+", " ");
            String anchorsXpath = scope.getTagName().equalsIgnoreCase("ul") ? "./li/a" : "./ul/li/a";
            List<WebElement> anchors = scope.findElements(By.xpath(anchorsXpath));

            WebElement link = anchors.stream().filter(a -> {
                String direct = (String) js.executeScript(
                        "const a=arguments[0]; return [...a.childNodes].filter(n=>n.nodeType===3)" +
                                ".map(n=>n.textContent).join('').replace(/\\s+/g,' ').trim();",
                        a);
                return label.equals(direct);
            }).findFirst().orElseThrow(() -> new NoSuchElementException("Not found: " + label));

            js.executeScript("arguments[0].scrollIntoView({block:'center'});", link);
            wait.until(ExpectedConditions.visibilityOf(link));

            boolean isLeaf = (i == labels.length - 1);
            if (isLeaf) {
                try {
                    wait.until(ExpectedConditions.elementToBeClickable(link)).click();
                } catch (Exception e) {
                    js.executeScript("arguments[0].click();", link);
                }
                return;
            } else {
                WebElement li = link.findElement(By.xpath("./ancestor::li[1]"));
                try {
                    actions.moveToElement(link).pause(Duration.ofMillis(150)).perform();
                    waitChildVisibleByJs(driver, li, Duration.ofSeconds(2));
                } catch (Exception e) {
                    try {
                        link.click();
                    } catch (Exception ex) {
                        js.executeScript("arguments[0].click();", link);
                    }
                    waitChildVisibleByJs(driver, li, Duration.ofSeconds(4));
                }
                scope = li;
            }
        }
    }

    private static boolean waitChildVisibleByJs(WebDriver driver, WebElement li, Duration timeout) {
        WebDriverWait w = new WebDriverWait(driver, timeout);
        try {
            return w.until(d -> {
                try {
                    WebElement ul = li.findElement(By.xpath("./ul"));
                    Object visible = ((JavascriptExecutor) d).executeScript(
                            "const u=arguments[0]; if(!u) return false;" +
                                    "const s=getComputedStyle(u);" +
                                    "if(s.display==='none' || s.visibility==='hidden' || +s.opacity===0) return false;"
                                    +
                                    "const r=u.getBoundingClientRect(); return r.width>0 && r.height>0;",
                            ul);
                    return Boolean.TRUE.equals(visible);
                } catch (Exception e) {
                    return false;
                }
            });
        } catch (TimeoutException e) {
            return false;
        }
    }

    private static String compareFiles(String preFilePath, String postFilePath, ApplicationData app) {
        StringBuilder result = new StringBuilder();
        result.append("File: ").append(app.fileName).append("\n");

        try {
            List<String> preLines = Files.readAllLines(Paths.get(preFilePath));
            List<String> postLines = Files.readAllLines(Paths.get(postFilePath));

            List<String> preNorm = normalizeContent(removeMetadata(preLines));
            List<String> postNorm = normalizeContent(removeMetadata(postLines));

            if (preNorm.equals(postNorm)) {
                result.append("Status: ‚úÖ MATCHED\n");
            } else {
                result.append("Status: ‚ö†Ô∏è DIFFERENCES FOUND\n");
                result.append(findDifferences(preLines, postLines));
            }

        } catch (IOException e) {
            result.append("Status: ‚ùå ERROR - ").append(e.getMessage()).append("\n");
        }

        return result.toString();
    }

    private static List<String> normalizeContent(List<String> lines) {
        return lines.stream().map(String::trim).filter(l -> !l.isEmpty()).collect(Collectors.toList());
    }

    private static List<String> removeMetadata(List<String> lines) {
        List<String> filtered = new ArrayList<>();
        boolean skip = true;

        for (String line : lines) {
            if (skip && line.contains("==================================")) {
                skip = false;
                continue;
            }
            if (line.contains("Extraction Time:") || line.contains("Application ID:") || line.startsWith("Type:")) {
                continue;
            }
            if (!skip) {
                filtered.add(line);
            }
        }

        return filtered;
    }

    private static String findDifferences(List<String> preLines, List<String> postLines) {
        StringBuilder diff = new StringBuilder();
        int maxLines = Math.max(preLines.size(), postLines.size());
        int diffCount = 0;
        int displayedDiffs = 0;
        final int MAX_DISPLAY = 20;

        for (int i = 0; i < maxLines; i++) {
            String preLine = i < preLines.size() ? preLines.get(i).trim() : "[MISSING]";
            String postLine = i < postLines.size() ? postLines.get(i).trim() : "[MISSING]";

            if (preLine.isEmpty() && postLine.isEmpty())
                continue;
            if (preLine.contains("Extraction Time:") || postLine.contains("Extraction Time:"))
                continue;

            if (!preLine.equals(postLine)) {
                diffCount++;

                if (displayedDiffs < MAX_DISPLAY) {
                    diff.append("\nLine ").append(i + 1).append(":\n");
                    String preDisplay = preLine.length() > 100 ? preLine.substring(0, 100) + "..." : preLine;
                    String postDisplay = postLine.length() > 100 ? postLine.substring(0, 100) + "..." : postLine;
                    diff.append("  PRE:  ").append(preDisplay).append("\n");
                    diff.append("  POST: ").append(postDisplay).append("\n");
                    displayedDiffs++;
                }
            }
        }

        if (diffCount > MAX_DISPLAY) {
            diff.append("\n... and ").append(diffCount - MAX_DISPLAY).append(" more differences\n");
        }

        diff.append("\nTotal differences: ").append(diffCount);
        return diff.toString();
    }

    // Excel and JSON parsing methods (same as original)
    private static String compareAppIDsSingleFile(String preFolderPath, String postFolderPath,
            String outputFolder) throws Exception {
        ObjectMapper mapper = new ObjectMapper();

        Map<String, String> preAppIds = extractAppIDs(preFolderPath, mapper);
        Map<String, String> postAppIds = extractAppIDs(postFolderPath, mapper);

        Set<String> allFileNames = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
        allFileNames.addAll(preAppIds.keySet());
        allFileNames.addAll(postAppIds.keySet());

        File outDir = new File(outputFolder);
        if (!outDir.exists() && !outDir.mkdirs()) {
            throw new IllegalStateException("Failed to create output dir: " + outDir);
        }

        List<RowData> allRows = new ArrayList<>();
        for (String fileName : allFileNames) {
            ApplicationData tempApp = new ApplicationData(fileName,
                    preAppIds.getOrDefault(fileName, ""),
                    postAppIds.getOrDefault(fileName, ""));
            allRows.add(new RowData(fileName, tempApp.preAppId, tempApp.postAppId, tempApp.category));
        }

        if (allRows.isEmpty()) {
            System.out.println("No data to process.");
            return null;
        }

        String outPath = new File(outDir, "APPIDComparison_ALL.xlsx").getAbsolutePath();
        writeUnifiedExcel(allRows, outPath);
        System.out.println("‚úÖ Excel created: " + outPath + " (" + allRows.size() + " rows)");

        return outPath;
    }

    static class RowData {
        String fileName, preAppId, postAppId, category;

        RowData(String fileName, String preAppId, String postAppId, String category) {
            this.fileName = fileName;
            this.preAppId = preAppId;
            this.postAppId = postAppId;
            this.category = category;
        }
    }

    private static Map<String, String> extractAppIDs(String folderPath, ObjectMapper mapper) throws Exception {
        Map<String, String> appIds = new ConcurrentHashMap<>();
        File folder = new File(folderPath);

        if (!folder.exists() || !folder.isDirectory()) {
            System.out.println("‚ö†Ô∏è Folder not found: " + folderPath);
            return appIds;
        }

        File[] files = folder.listFiles();
        if (files == null)
            return appIds;

        Arrays.stream(files)
                .filter(file -> file != null && file.isFile())
                .parallel()
                .forEach(file -> {
                    String name = file.getName();

                    if (name.toLowerCase(Locale.ROOT).endsWith(".json") ||
                            name.toLowerCase(Locale.ROOT).endsWith(".txt")) {

                        try {
                            String content = readFileWithEncoding(file);
                            String appId = "";

                            if (name.endsWith(".json")) {
                                JsonNode root = mapper.readTree(content);
                                appId = findAppId(root);
                            } else if (name.endsWith(".txt")) {
                                appId = extractAppIdFromTxtFileName(name);
                                if (appId.isEmpty()) {
                                    appId = extractAppIdFromTxtContent(content);
                                }
                            }

                            appIds.put(name, appId);
                        } catch (Exception e) {
                            System.out.println("‚ö†Ô∏è Failed to parse " + name);
                            appIds.put(name, "");
                        }
                    }
                });

        return appIds;
    }

    private static String readFileWithEncoding(File file) throws IOException {
        try {
            String content = Files.readString(file.toPath(), StandardCharsets.UTF_8);
            if (!content.contains("\uFFFD")) {
                return content;
            }
        } catch (Exception e) {
        }

        try {
            return Files.readString(file.toPath(), Charset.forName("Windows-1252"));
        } catch (Exception e) {
            return Files.readString(file.toPath(), Charset.defaultCharset());
        }
    }

    private static String extractAppIdFromTxtFileName(String fileName) {
        Pattern pattern = Pattern.compile("_(PRE|POST)_(\\d+)\\.txt$");
        Matcher matcher = pattern.matcher(fileName);
        return matcher.find() ? matcher.group(2) : "";
    }

    private static String extractAppIdFromTxtContent(String content) {
        Pattern pattern = Pattern.compile("Application ID:\\s*(\\d+)");
        Matcher matcher = pattern.matcher(content);
        return matcher.find() ? matcher.group(1) : "";
    }

    private static String findAppId(JsonNode node) {
        if (node == null || node.isMissingNode() || node.isNull())
            return "";

        if (node.isObject()) {
            for (String key : APPID_KEYS) {
                JsonNode candidate = node.get(key);
                String v = nodeToIdString(candidate);
                if (!v.isEmpty())
                    return v;
            }

            Iterator<Map.Entry<String, JsonNode>> it = node.fields();
            while (it.hasNext()) {
                Map.Entry<String, JsonNode> e = it.next();
                String fieldName = e.getKey();
                JsonNode value = e.getValue();

                if (fieldName != null && fieldName.toLowerCase(Locale.ROOT).contains("appid")) {
                    String v = nodeToIdString(value);
                    if (!v.isEmpty())
                        return v;
                }

                String deeper = findAppId(value);
                if (!deeper.isEmpty())
                    return deeper;
            }
        }

        if (node.isArray()) {
            for (JsonNode item : node) {
                String v = findAppId(item);
                if (!v.isEmpty())
                    return v;
            }
        }

        return "";
    }

    private static String nodeToIdString(JsonNode n) {
        if (n == null || n.isMissingNode() || n.isNull())
            return "";
        if (n.isTextual() || n.isNumber() || n.isBoolean()) {
            return n.asText();
        }
        if (n.isObject()) {
            for (String idKey : ID_KEYS) {
                JsonNode inner = n.get(idKey);
                if (inner != null && !inner.isNull()) {
                    String v = nodeToIdString(inner);
                    if (!v.isEmpty())
                        return v;
                }
            }
        }
        return "";
    }

    private static void writeUnifiedExcel(List<RowData> rows, String excelPath) throws Exception {
        try (Workbook workbook = new XSSFWorkbook();
                FileOutputStream fos = new FileOutputStream(excelPath)) {

            Sheet sheet = workbook.createSheet("AppID Comparison");

            Row header = sheet.createRow(0);
            header.createCell(0).setCellValue("File Name");
            header.createCell(1).setCellValue("Pre-AppID");
            header.createCell(2).setCellValue("Post-AppID");
            header.createCell(3).setCellValue("Category");

            int rowIndex = 1;
            for (RowData rd : rows) {
                Row r = sheet.createRow(rowIndex++);
                r.createCell(0).setCellValue(rd.fileName);
                r.createCell(1).setCellValue(rd.preAppId);
                r.createCell(2).setCellValue(rd.postAppId);
                r.createCell(3).setCellValue(rd.category);
            }

            for (int i = 0; i < 4; i++)
                sheet.autoSizeColumn(i);
            workbook.write(fos);
        }
    }

    private static List<ApplicationData> readUnifiedExcelFile(String excelPath) {
        List<ApplicationData> applications = new ArrayList<>();

        try (FileInputStream fis = new FileInputStream(excelPath);
                Workbook workbook = new XSSFWorkbook(fis)) {

            Sheet sheet = workbook.getSheetAt(0);

            for (int i = 1; i <= sheet.getLastRowNum(); i++) {
                Row row = sheet.getRow(i);
                if (row == null)
                    continue;

                String fileName = getCellValueAsString(row.getCell(0));
                String preAppId = getCellValueAsString(row.getCell(1));
                String postAppId = getCellValueAsString(row.getCell(2));

                ApplicationData appData = new ApplicationData(fileName, preAppId, postAppId);

                if (appData.isValid()) {
                    applications.add(appData);
                }
            }

        } catch (IOException e) {
            System.err.println("Error reading Excel: " + e.getMessage());
        }

        return applications;
    }

    private static String getCellValueAsString(Cell cell) {
        if (cell == null)
            return null;

        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue().trim();
            case NUMERIC:
                double numValue = cell.getNumericCellValue();
                if (numValue == Math.floor(numValue)) {
                    return String.valueOf((long) numValue);
                }
                return String.valueOf(numValue);
            case BLANK:
                return null;
            default:
                return cell.toString().trim();
        }
    }

    private static void generateMasterReport(ConcurrentLinkedQueue<String> reports,
            String outputFolder, int totalApps) throws IOException {
        StringBuilder report = new StringBuilder();
        report.append("‚ïê".repeat(70)).append("\n");
        report.append("               MASTER BUREAU COMPARISON REPORT\n");
        report.append("‚ïê".repeat(70)).append("\n");
        report.append("Generated: ").append(LocalDateTime.now()).append("\n");
        report.append("Total Applications: ").append(totalApps).append("\n");
        report.append("‚ïê".repeat(70)).append("\n\n");

        for (String r : reports) {
            report.append(r).append("\n\n");
        }

        String reportPath = outputFolder + File.separator + "MASTER_comparison_report.txt";
        Files.writeString(Paths.get(reportPath), report.toString(), StandardCharsets.UTF_8);
        System.out.println("‚úÖ Master report saved: " + reportPath);
    }

    private static void sleepSeconds(int seconds) {
        try {
            Thread.sleep(seconds * 1000L);
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
        }
    }
}
