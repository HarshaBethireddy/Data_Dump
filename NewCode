package com.harsha.extractor;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.openqa.selenium.*;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.TimeoutException;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class ExtractorPortable {

    // Configuration loaded from config.properties
    private static String BASE_URL;
    private static String USERNAME;
    private static String PASSWORD;
    private static String BASE_PRE_FOLDER;
    private static String BASE_POST_FOLDER;
    private static String BASE_OUTPUT_DIRECTORY;
    private static int NUM_BROWSER_INSTANCES;
    private static int BROWSERS_PER_CATEGORY;
    private static String ADMIN_GROUP;

    private static final DateTimeFormatter RUN_DIR_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss_SSS");
    private static String CHECKPOINT_FILE = null;

    private static final Map<String, CategoryConfig> CATEGORY_CONFIGS = new HashMap<>();
    static {
        CATEGORY_CONFIGS.put("ACQ", new CategoryConfig(
                new String[] { "View Only", "Credit Full", "All" }));
        CATEGORY_CONFIGS.put("CLI", new CategoryConfig(
                new String[] { "View Only", "CLI Credit Full", "All" }));
        CATEGORY_CONFIGS.put("PRQ", new CategoryConfig(
                new String[] { "View Only", "PreQual Credit Full", "All" }));
        CATEGORY_CONFIGS.put("PREQUAL", new CategoryConfig(
                new String[] { "View Only", "PreQual Credit Full", "All" }));
        CATEGORY_CONFIGS.put("Prequal", new CategoryConfig(
                new String[] { "View Only", "PreQual Credit Full", "All" }));
        CATEGORY_CONFIGS.put("PreQual", new CategoryConfig(
                new String[] { "View Only", "PreQual Credit Full", "All" }));
    }

    private static final List<String> APPID_KEYS = Arrays.asList(
            "APPID", "AppID", "AppId", "appId", "appid", "APP_ID", "app_id", "APP-ID", "app-id");
    private static final List<String> ID_KEYS = Arrays.asList("id", "ID", "Id", "value", "appId", "APPID");

    /**
     * Load configuration from config.properties file
     */
    private static void loadConfiguration() {
        Properties props = new Properties();
        String configPath = "config.properties";

        try (InputStream input = new FileInputStream(configPath)) {
            props.load(input);

            BASE_URL = props.getProperty("base.url");
            USERNAME = props.getProperty("username");
            PASSWORD = props.getProperty("password");

            // Get application directory (where JAR is located)
            String appDir = System.getProperty("user.dir");

            BASE_PRE_FOLDER = appDir + File.separator + props.getProperty("pre.folder.name", "pre");
            BASE_POST_FOLDER = appDir + File.separator + props.getProperty("post.folder.name", "post");
            BASE_OUTPUT_DIRECTORY = appDir + File.separator + props.getProperty("output.folder.name", "comparisons");

            NUM_BROWSER_INSTANCES = Integer.parseInt(props.getProperty("num.browser.instances", "15"));
            BROWSERS_PER_CATEGORY = Integer.parseInt(props.getProperty("browsers.per.category", "5"));
            ADMIN_GROUP = props.getProperty("admin.group", "Administrators");

            System.out.println("‚úÖ Configuration loaded successfully");
            System.out.println("   PRE Folder: " + BASE_PRE_FOLDER);
            System.out.println("   POST Folder: " + BASE_POST_FOLDER);
            System.out.println("   Output Directory: " + BASE_OUTPUT_DIRECTORY);

        } catch (IOException e) {
            System.err.println("‚ùå ERROR: Could not load config.properties file!");
            System.err.println("   Make sure config.properties exists in the same folder as this program.");
            System.err.println("   Error details: " + e.getMessage());
            System.exit(1);
        }
    }

    /**
     * Validate that required folders exist
     */
    private static void validateFolders() {
        File preFolder = new File(BASE_PRE_FOLDER);
        File postFolder = new File(BASE_POST_FOLDER);
        File outputFolder = new File(BASE_OUTPUT_DIRECTORY);

        if (!preFolder.exists()) {
            if (!preFolder.mkdirs()) {
                System.err.println("‚ùå ERROR: Could not create PRE folder: " + BASE_PRE_FOLDER);
                System.exit(1);
            }
            System.out.println("üìÅ Created PRE folder: " + BASE_PRE_FOLDER);
        }

        if (!postFolder.exists()) {
            if (!postFolder.mkdirs()) {
                System.err.println("‚ùå ERROR: Could not create POST folder: " + BASE_POST_FOLDER);
                System.exit(1);
            }
            System.out.println("üìÅ Created POST folder: " + BASE_POST_FOLDER);
        }

        if (!outputFolder.exists()) {
            if (!outputFolder.mkdirs()) {
                System.err.println("‚ùå ERROR: Could not create OUTPUT folder: " + BASE_OUTPUT_DIRECTORY);
                System.exit(1);
            }
            System.out.println("üìÅ Created OUTPUT folder: " + BASE_OUTPUT_DIRECTORY);
        }
    }

    private static JavascriptExecutor js(WebDriver driver) {
        return (JavascriptExecutor) driver;
    }

    private static WebElement waitForPresent(WebDriverWait wait, By locator) {
        return wait.until(ExpectedConditions.presenceOfElementLocated(locator));
    }

    private static WebElement waitForVisible(WebDriverWait wait, By locator) {
        return wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
    }

    private static void jsClick(WebDriver driver, WebDriverWait wait, By locator) {
        retryRun(6, 400, () -> {
            WebElement el = waitForVisible(wait, locator);
            scrollIntoViewCenter(driver, el);
            js(driver).executeScript("arguments[0].click();", el);
        });
    }

    private static void jsType(WebDriver driver, WebDriverWait wait, By locator, String text) {
        retryRun(6, 400, () -> {
            WebElement el = waitForVisible(wait, locator);
            scrollIntoViewCenter(driver, el);
            js(driver).executeScript(
                    "const el=arguments[0], val=arguments[1];" +
                    "el.focus();" +
                    "el.value='';" +
                    "el.value=val;" +
                    "el.dispatchEvent(new Event('input',{bubbles:true}));" +
                    "el.dispatchEvent(new Event('change',{bubbles:true}));",
                    el, text);
        });
    }

    private static void jsSelectByVisibleText(WebDriver driver, WebDriverWait wait, By selectLocator, String visibleText) {
        retryRun(6, 400, () -> {
            WebElement sel = waitForVisible(wait, selectLocator);
            scrollIntoViewCenter(driver, sel);
            js(driver).executeScript(
                    "const sel=arguments[0], txt=arguments[1];" +
                    "let found=false;" +
                    "for (const o of sel.options) {" +
                    " if ((o.text||'').trim()===txt) { o.selected=true; sel.value=o.value; found=true; break; }" +
                    "}" +
                    "if(!found){throw new Error('Option with text '+txt+' not found');}" +
                    "sel.dispatchEvent(new Event('input',{bubbles:true}));" +
                    "sel.dispatchEvent(new Event('change',{bubbles:true}));",
                    sel, visibleText);
        });
    }

    private static void sendKeysStableForAppId(WebDriver driver, WebDriverWait wait, By locator, String value) {
        retryRun(8, 500, () -> {
            WebElement el = waitForVisible(wait, locator);
            scrollIntoViewCenter(driver, el);
            el.click();
            el.sendKeys(Keys.chord(Keys.CONTROL, "a"));
            el.sendKeys(Keys.DELETE);
            sleepSeconds(1);
            for (char c : value.toCharArray()) {
                el.sendKeys(String.valueOf(c));
            }
            wait.until(ExpectedConditions.attributeToBe(locator, "value", value));
        });
    }

    private static void scrollIntoViewCenter(WebDriver driver, WebElement el) {
        try {
            js(driver).executeScript(
                    "arguments[0].scrollIntoView({block:'center', inline:'center'});", el);
        } catch (JavascriptException ignored) {}
    }

    private static void retryRun(int attempts, long sleepMs, Runnable action) {
        int tries = 0;
        while (true) {
            try {
                action.run();
                return;
            } catch (StaleElementReferenceException | JavascriptException | NoSuchElementException e) {
                tries++;
                if (tries >= attempts) throw e;
                sleepQuiet(sleepMs);
            } catch (TimeoutException te) {
                tries++;
                if (tries >= attempts) throw te;
                sleepQuiet(sleepMs);
            }
        }
    }

    private static void sleepQuiet(long ms) {
        try { Thread.sleep(ms); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); }
    }

    private static File findLatestIncompleteRun(String preFolderName, String postFolderName) {
        File baseDir = new File(BASE_OUTPUT_DIRECTORY);
        if (!baseDir.exists() || !baseDir.isDirectory()) return null;

        File[] subDirs = baseDir.listFiles(File::isDirectory);
        if (subDirs == null || subDirs.length == 0) return null;

        File latestIncomplete = null;
        long latestTimestamp = 0;

        for (File dir : subDirs) {
            File metadataFile = new File(dir, "run_metadata.json");
            File checkpointFile = new File(dir, "checkpoint_progress.json");
            if (metadataFile.exists()) {
                try {
                    ObjectMapper mapper = new ObjectMapper();
                    RunMetadata metadata = mapper.readValue(metadataFile, RunMetadata.class);
                    if (metadata.preFolderName.equals(preFolderName)
                            && metadata.postFolderName.equals(postFolderName)
                            && !metadata.completed) {
                        if (checkpointFile.exists()) {
                            long timestamp = dir.lastModified();
                            if (timestamp > latestTimestamp) {
                                latestTimestamp = timestamp;
                                latestIncomplete = dir;
                            }
                        }
                    }
                } catch (IOException ignored) { }
            }
        }
        return latestIncomplete;
    }

    private static void saveFolderMetadata(String outputFolder, String preFolderName, String postFolderName) {
        try {
            RunMetadata metadata = new RunMetadata();
            metadata.preFolderName = preFolderName;
            metadata.postFolderName = postFolderName;
            metadata.startTime = LocalDateTime.now().toString();
            metadata.completed = false;
            ObjectMapper mapper = new ObjectMapper();
            String metadataPath = outputFolder + "\\run_metadata.json";
            mapper.writerWithDefaultPrettyPrinter().writeValue(new File(metadataPath), metadata);
        } catch (IOException e) {
            System.err.println("‚ö†Ô∏è Could not save run metadata: " + e.getMessage());
        }
    }

    private static void markRunCompleted(String outputFolder) {
        try {
            File metadataFile = new File(outputFolder, "run_metadata.json");
            if (metadataFile.exists()) {
                ObjectMapper mapper = new ObjectMapper();
                RunMetadata metadata = mapper.readValue(metadataFile, RunMetadata.class);
                metadata.completed = true;
                metadata.endTime = LocalDateTime.now().toString();
                mapper.writerWithDefaultPrettyPrinter().writeValue(metadataFile, metadata);
            }
        } catch (IOException e) {
            System.err.println("‚ö†Ô∏è Could not update run metadata: " + e.getMessage());
        }
    }

    static class RunMetadata {
        public String preFolderName;
        public String postFolderName;
        public String startTime;
        public String endTime;
        public boolean completed;
    }

    static class CheckpointManager {
        private final String checkpointFilePath;
        private final Set<String> completedApps;
        private final ObjectMapper mapper;

        CheckpointManager(String outputFolder) {
            this.checkpointFilePath = outputFolder + "\\checkpoint_progress.json";
            this.completedApps = Collections.synchronizedSet(new HashSet<>());
            this.mapper = new ObjectMapper();
            loadCheckpoint();
        }

        private void loadCheckpoint() {
            File checkpointFile = new File(checkpointFilePath);
            if (checkpointFile.exists()) {
                try {
                    CheckpointData data = mapper.readValue(checkpointFile, CheckpointData.class);
                    completedApps.addAll(data.completedApplications);
                    System.out.println("‚úÖ Loaded checkpoint: " + completedApps.size() + " applications already completed");
                } catch (IOException e) {
                    System.err.println("‚ö†Ô∏è Could not load checkpoint: " + e.getMessage());
                }
            }
        }

        public synchronized void saveCheckpoint() {
            try {
                CheckpointData data = new CheckpointData();
                data.completedApplications = new ArrayList<>(completedApps);
                data.lastUpdated = LocalDateTime.now().toString();
                data.totalCompleted = completedApps.size();
                mapper.writerWithDefaultPrettyPrinter().writeValue(new File(checkpointFilePath), data);
            } catch (IOException e) {
                System.err.println("‚ö†Ô∏è Could not save checkpoint: " + e.getMessage());
            }
        }

        public boolean isCompleted(String appKey) {
            return completedApps.contains(appKey);
        }

        public void markCompleted(String appKey) {
            completedApps.add(appKey);
            saveCheckpoint();
        }

        public int getCompletedCount() {
            return completedApps.size();
        }

        static class CheckpointData {
            public List<String> completedApplications;
            public String lastUpdated;
            public int totalCompleted;
        }
    }

    static class CategoryConfig {
        String[] menuPath;
        CategoryConfig(String... menuPath) {
            this.menuPath = menuPath;
        }
    }

    static class ApplicationData {
        String fileName;
        String preAppId;
        String postAppId;
        String category;
        ApplicationData(String fileName, String preAppId, String postAppId) {
            this.fileName = fileName;
            this.preAppId = preAppId;
            this.postAppId = postAppId;
            this.category = determineCategory(fileName);
        }
        boolean isValid() {
            return fileName != null && !fileName.trim().isEmpty()
                    && preAppId != null && !preAppId.trim().isEmpty()
                    && postAppId != null && !postAppId.trim().isEmpty();
        }
        String getUniqueKey() {
            return fileName + "_" + preAppId + "_" + postAppId;
        }
        private String determineCategory(String fileName) {
            if (fileName == null) return "UNKNOWN";
            String u = fileName.toUpperCase(Locale.ROOT);
            if (u.contains("CLI")) return "CLI";
            if (u.contains("PRQ") || u.contains("PREQUAL")) return "PRQ";
            if (u.contains("ACQ")) return "ACQ";
            return "ACQ";
        }
    }

    static class RowData {
        String fileName;
        String preAppId;
        String postAppId;
        String category;
        RowData(String fileName, String preAppId, String postAppId, String category) {
            this.fileName = fileName;
            this.preAppId = preAppId;
            this.postAppId = postAppId;
            this.category = category;
        }
    }

    static class BureauSection {
        String bureauName;
        String type;
        int startLine;
        int endLine;
        BureauSection(String bureauName, String type, int startLine, int endLine) {
            this.bureauName = bureauName;
            this.type = type;
            this.startLine = startLine;
            this.endLine = endLine;
        }
    }

    static class BrowserInstance {
        WebDriver driver;
        WebDriverWait wait;
        int instanceId;
        BrowserInstance(int instanceId) {
            this.instanceId = instanceId;
            ChromeOptions options = new ChromeOptions();
            options.addArguments("--start-maximized");
            options.addArguments("--disable-blink-features=AutomationControlled");
            options.addArguments("--headless=new");
            this.driver = new ChromeDriver(options);
            this.wait = new WebDriverWait(driver, Duration.ofSeconds(60));
        }
        void cleanup() {
            try {
                if (driver != null) driver.quit();
            } catch (Exception e) {
                System.err.println("Error closing browser instance " + instanceId + ": " + e.getMessage());
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ExecutorService executorService = null;
        try {
            System.out.println("=== Bureau Data Comparison Tool (Portable Version) ===\n");

            // Load configuration
            loadConfiguration();
            validateFolders();

            System.out.println("\n‚úÖ Setup complete! Ready to process data.");
            System.out.println("\nIMPORTANT: Make sure you have placed your files in:");
            System.out.println("  - PRE data: " + BASE_PRE_FOLDER);
            System.out.println("  - POST data: " + BASE_POST_FOLDER);
            System.out.print("\nPress Enter to continue...");
            scanner.nextLine();

            // Use folder names relative to base directory
            String preFolderName = new File(BASE_PRE_FOLDER).getName();
            String postFolderName = new File(BASE_POST_FOLDER).getName();
            String preFolderPath = BASE_PRE_FOLDER;
            String postFolderPath = BASE_POST_FOLDER;

            final String outputFolder;
            final String excelFilePath;
            boolean isResume = false;

            File existingRun = findLatestIncompleteRun(preFolderName, postFolderName);
            if (existingRun != null) {
                System.out.println("\n‚ö†Ô∏è Found incomplete run from previous session:");
                System.out.println("   " + existingRun.getName());
                System.out.print("Do you want to RESUME this run? (yes/no): ");
                String response = scanner.nextLine().trim().toLowerCase(Locale.ROOT);
                if (response.equals("yes") || response.equals("y")) {
                    outputFolder = existingRun.getAbsolutePath();
                    excelFilePath = outputFolder + "\\APPIDComparison_ALL.xlsx";
                    isResume = true;
                    System.out.println("‚úÖ Resuming from: " + outputFolder);
                } else {
                    System.out.println("Starting fresh run...");
                    String tempFolder = BASE_OUTPUT_DIRECTORY + "\\comparison_" +
                            LocalDateTime.now().format(RUN_DIR_FORMATTER);
                    String tempExcel = compareAppIDsSingleFile(preFolderPath, postFolderPath, tempFolder);
                    if (tempExcel == null) {
                        System.out.println("\nNo Excel file generated. Exiting.");
                        return;
                    }
                    saveFolderMetadata(tempFolder, preFolderName, postFolderName);
                    outputFolder = tempFolder;
                    excelFilePath = tempExcel;
                }
            } else {
                System.out.println("\n=== Step 1: Comparing APP IDs ===");
                String tempFolder = BASE_OUTPUT_DIRECTORY + "\\comparison_" +
                        LocalDateTime.now().format(RUN_DIR_FORMATTER);
                String tempExcel = compareAppIDsSingleFile(preFolderPath, postFolderPath, tempFolder);
                if (tempExcel == null) {
                    System.out.println("\nNo Excel file generated. Exiting.");
                    return;
                }
                saveFolderMetadata(tempFolder, preFolderName, postFolderName);
                outputFolder = tempFolder;
                excelFilePath = tempExcel;
            }

            CheckpointManager checkpointManager = new CheckpointManager(outputFolder);
            CHECKPOINT_FILE = outputFolder + "\\checkpoint_progress.json";

            System.out.println("\n=== Step 2: Extracting Bureau Data (TRUE Parallel Processing) ===");
            System.out.println("Processing Excel file: " + excelFilePath);
            System.out.println("Using up to " + NUM_BROWSER_INSTANCES + " parallel browser instances");
            System.out.println("Checkpoint file: " + CHECKPOINT_FILE);

            executorService = Executors.newFixedThreadPool(NUM_BROWSER_INSTANCES);

            List<ApplicationData> applications = readUnifiedExcelFile(excelFilePath);
            List<ApplicationData> remainingApps = applications.stream()
                    .filter(app -> !checkpointManager.isCompleted(app.getUniqueKey()))
                    .collect(Collectors.toList());

            System.out.println("Total applications: " + applications.size());
            System.out.println("Already completed: " + checkpointManager.getCompletedCount());
            System.out.println("Remaining to process: " + remainingApps.size());

            if (remainingApps.isEmpty()) {
                System.out.println("\n‚úÖ All applications already processed!");
                return;
            }

            Map<String, List<ApplicationData>> categoryGroups = remainingApps.stream()
                    .collect(Collectors.groupingBy(app -> app.category));

            System.out.println("Categories: " + categoryGroups.keySet());

            List<Future<CategoryProcessingResult>> futures = new ArrayList<>();

            for (Map.Entry<String, List<ApplicationData>> entry : categoryGroups.entrySet()) {
                String category = entry.getKey();
                List<ApplicationData> categoryApps = entry.getValue();

                int browsersForCategory = Math.min(BROWSERS_PER_CATEGORY, categoryApps.size());
                int appsPerBrowser = (int) Math.ceil((double) categoryApps.size() / browsersForCategory);
                System.out.println("\n[" + category + "] Splitting " + categoryApps.size() +
                        " apps across " + browsersForCategory + " browsers");

                for (int i = 0; i < browsersForCategory; i++) {
                    int startIdx = i * appsPerBrowser;
                    int endIdx = Math.min(startIdx + appsPerBrowser, categoryApps.size());
                    if (startIdx >= categoryApps.size()) break;
                    List<ApplicationData> batchApps = categoryApps.subList(startIdx, endIdx);
                    int browserNum = i + 1;
                    Future<CategoryProcessingResult> future = executorService.submit(
                            () -> processCategoryBatchWithBrowser(category, batchApps, outputFolder, browserNum, checkpointManager));
                    futures.add(future);
                }
            }

            StringBuilder masterReport = new StringBuilder();
            masterReport.append("===== MASTER BUREAU DATA COMPARISON REPORT =====\n");
            masterReport.append("Generated: ").append(LocalDateTime.now()).append("\n");
            masterReport.append("Total Applications: ").append(applications.size()).append("\n");
            masterReport.append("Processed in this run: ").append(remainingApps.size()).append("\n");
            masterReport.append("==============================================\n\n");

            int completedFutures = 0;
            for (Future<CategoryProcessingResult> future : futures) {
                try {
                    CategoryProcessingResult result = future.get();
                    masterReport.append(result.report);
                    completedFutures++;
                    System.out.println("\n‚úÖ Completed batch " + completedFutures + "/" + futures.size() + ": " + result.category);
                } catch (Exception e) {
                    System.err.println("Error processing batch: " + e.getMessage());
                    e.printStackTrace();
                }
            }

            String masterReportPath = outputFolder + "\\MASTER_comparison_report.txt";
            try (FileWriter writer = new FileWriter(masterReportPath)) {
                writer.write(masterReport.toString());
                System.out.println("\n‚úÖ Master comparison report saved: " + masterReportPath);
            }

            markRunCompleted(outputFolder);
            System.out.println("\n=== All Processing Complete ===");
            System.out.println("Output location: " + outputFolder);
            System.out.println("Total completed: " + checkpointManager.getCompletedCount() + "/" + applications.size());
            System.out.println("\n‚úÖ This run has been marked as COMPLETED.");
            System.out.println("   Next time you run with same folders, you can start fresh or process new data.");

        } catch (Exception e) {
            System.err.println("Error in main execution: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (executorService != null) {
                executorService.shutdown();
                try {
                    if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) executorService.shutdownNow();
                } catch (InterruptedException e) {
                    executorService.shutdownNow();
                    Thread.currentThread().interrupt();
                }
            }
            scanner.close();
            System.out.println("\nPress Enter to exit...");
            try { System.in.read(); } catch (IOException ignored) {}
        }
    }

    static class CategoryProcessingResult {
        String category;
        String report;
        CategoryProcessingResult(String category, String report) {
            this.category = category;
            this.report = report;
        }
    }

    private static CategoryProcessingResult processCategoryBatchWithBrowser(
            String category, List<ApplicationData> apps, String baseOutputFolder,
            int browserNum, CheckpointManager checkpointManager) {

        BrowserInstance browser = null;
        StringBuilder categoryReport = new StringBuilder();

        try {
            System.out.println("\n[" + category + " #" + browserNum + "] Starting with " + apps.size() + " applications");
            browser = new BrowserInstance((category + browserNum).hashCode());

            if (!performLogin(browser.driver, browser.wait)) {
                throw new RuntimeException("Login failed for: " + category + " #" + browserNum);
            }

            if (!selectAdministratorGroup(browser.driver, browser.wait)) {
                throw new RuntimeException("Failed to select Administrator group");
            }

            CategoryConfig config = CATEGORY_CONFIGS.get(category);
            if (config == null) throw new RuntimeException("Unknown category: " + category);

            if (!navigateToSearchScreen(browser.driver, browser.wait, config)) {
                throw new RuntimeException("Failed to navigate to search");
            }

            String categoryOutputFolder = baseOutputFolder + "\\" + category + "\\";
            Files.createDirectories(Paths.get(categoryOutputFolder));

            categoryReport.append("===== CATEGORY: ").append(category)
                    .append(" - Browser #").append(browserNum).append(" =====\n");
            categoryReport.append("Applications: ").append(apps.size()).append("\n");
            categoryReport.append("==========================================\n\n");

            for (int i = 0; i < apps.size(); i++) {
                ApplicationData app = apps.get(i);

                if (checkpointManager.isCompleted(app.getUniqueKey())) {
                    System.out.println("[" + category + " #" + browserNum + "] Skipping (already done): " + app.fileName);
                    continue;
                }

                System.out.println("\n[" + category + " #" + browserNum + "] Processing (" + (i + 1) + "/" + apps.size() + "): " + app.fileName);

                String preOutputPath = categoryOutputFolder + app.fileName + "_PRE_" + app.preAppId + ".txt";
                boolean preSuccess = extractBureauDataForApplication(browser.driver, browser.wait, app.preAppId, preOutputPath, "PRE");
                if (preSuccess) {
                    navigateBackToSearch(browser.driver, browser.wait);
                }

                String postOutputPath = categoryOutputFolder + app.fileName + "_POST_" + app.postAppId + ".txt";
                boolean postSuccess = extractBureauDataForApplication(browser.driver, browser.wait, app.postAppId, postOutputPath, "POST");
                if (postSuccess && i < apps.size() - 1) {
                    navigateBackToSearch(browser.driver, browser.wait);
                }

                if (preSuccess && postSuccess) {
                    String comparisonResult = compareFilesWithBureauInfo(preOutputPath, postOutputPath, app);
                    categoryReport.append(comparisonResult).append("\n\n");
                    checkpointManager.markCompleted(app.getUniqueKey());
                    System.out.println("‚úÖ Checkpoint saved - Progress: " + checkpointManager.getCompletedCount() + " completed");
                } else {
                    String errorMsg = "File: " + app.fileName + "\nStatus: EXTRACTION FAILED\n"
                            + "Pre: " + (preSuccess ? "SUCCESS" : "FAILED") + "\n"
                            + "Post: " + (postSuccess ? "SUCCESS" : "FAILED");
                    categoryReport.append(errorMsg).append("\n\n");
                }
            }

            String categoryReportPath = categoryOutputFolder + "comparison_report_browser" + browserNum + ".txt";
            try (FileWriter writer = new FileWriter(categoryReportPath)) {
                writer.write(categoryReport.toString());
                System.out.println("\n[" + category + " #" + browserNum + "] ‚úÖ Category batch report saved");
            }

        } catch (Exception e) {
            System.err.println("[" + category + " #" + browserNum + "] Error: " + e.getMessage());
            e.printStackTrace();
            categoryReport.append("\n\nERROR: ").append(e.getMessage()).append("\n");
        } finally {
            if (browser != null) browser.cleanup();
        }

        return new CategoryProcessingResult(category + " #" + browserNum, categoryReport.toString());
    }

    private static String readFileWithEncoding(File file) throws IOException {
        try {
            String content = Files.readString(file.toPath(), StandardCharsets.UTF_8);
            if (!content.contains("\uFFFD")) return content;
        } catch (Exception ignored) {}
        try {
            return Files.readString(file.toPath(), Charset.forName("Windows-1252"));
        } catch (Exception ignored) {}
        try {
            return Files.readString(file.toPath(), Charset.forName("ISO-8859-1"));
        } catch (Exception ignored) {}
        return Files.readString(file.toPath(), Charset.defaultCharset());
    }

    private static String compareAppIDsSingleFile(String preFolderPath, String postFolderPath, String outputFolder) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        Map<String, String> preAppIds = extractAppIDs(preFolderPath, mapper);
        Map<String, String> postAppIds = extractAppIDs(postFolderPath, mapper);

        Set<String> allFileNames = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
        allFileNames.addAll(preAppIds.keySet());
        allFileNames.addAll(postAppIds.keySet());

        File outDir = new File(outputFolder);
        if (!outDir.exists() && !outDir.mkdirs()) {
            throw new IllegalStateException("Failed to create output directory: " + outDir.getAbsolutePath());
        }

        List<RowData> allRows = new ArrayList<>();
        for (String fileName : allFileNames) {
            ApplicationData tempApp = new ApplicationData(
                    fileName,
                    preAppIds.getOrDefault(fileName, ""),
                    postAppIds.getOrDefault(fileName, "")
            );
            allRows.add(new RowData(
                    fileName,
                    preAppIds.getOrDefault(fileName, ""),
                    postAppIds.getOrDefault(fileName, ""),
                    tempApp.category
            ));
        }

        if (allRows.isEmpty()) {
            System.out.println("No data to process.");
            return null;
        }

        String outPath = new File(outDir, "APPIDComparison_ALL.xlsx").getAbsolutePath();
        writeUnifiedExcel(allRows, outPath);
        System.out.println("Wrote: " + outPath + " (" + allRows.size() + " rows)");
        return outPath;
    }

    private static Map<String, String> extractAppIDs(String folderPath, ObjectMapper mapper) throws Exception {
        Map<String, String> appIds = new HashMap<>();
        File folder = new File(folderPath);
        if (!folder.exists() || !folder.isDirectory()) {
            System.out.println("Folder not found: " + folderPath);
            return appIds;
        }
        File[] files = folder.listFiles();
        if (files == null) return appIds;

        for (File file : files) {
            if (file == null || !file.isFile()) continue;
            String name = file.getName();
            String lower = name.toLowerCase(Locale.ROOT);
            if (lower.endsWith(".json") || lower.endsWith(".txt")) {
                try {
                    String content = readFileWithEncoding(file);
                    String appId = "";
                    if (lower.endsWith(".json")) {
                        JsonNode root = mapper.readTree(content);
                        appId = findAppId(root);
                    } else {
                        appId = extractAppIdFromTxtFileName(name);
                        if (appId.isEmpty()) appId = extractAppIdFromTxtContent(content);
                    }
                    appIds.put(name, appId);
                } catch (Exception e) {
                    System.out.println("‚ö†Ô∏è Failed to parse " + name + ": " + e.getMessage());
                    appIds.put(name, "");
                }
            }
        }
        return appIds;
    }

    private static String extractAppIdFromTxtFileName(String fileName) {
        Pattern p = Pattern.compile("_(PRE|POST)_(\\d+)\\.txt$");
        Matcher m = p.matcher(fileName);
        if (m.find()) return m.group(2);
        return "";
    }

    private static String extractAppIdFromTxtContent(String content) {
        Pattern p = Pattern.compile("Application ID:\\s*(\\d+)");
        Matcher m = p.matcher(content);
        if (m.find()) return m.group(1);
        return "";
    }

    private static String findAppId(JsonNode node) {
        if (node == null || node.isMissingNode() || node.isNull()) return "";
        if (node.isObject()) {
            for (String key : APPID_KEYS) {
                JsonNode candidate = node.get(key);
                String v = nodeToIdString(candidate);
                if (!v.isEmpty()) return v;
            }
            Iterator<Map.Entry<String, JsonNode>> it = node.fields();
            while (it.hasNext()) {
                Map.Entry<String, JsonNode> e = it.next();
                String fieldName = e.getKey();
                JsonNode value = e.getValue();
                if (fieldName != null && fieldName.toLowerCase(Locale.ROOT).contains("appid")) {
                    String v = nodeToIdString(value);
                    if (!v.isEmpty()) return v;
                }
                String deeper = findAppId(value);
                if (!deeper.isEmpty()) return deeper;
            }
        }
        if (node.isArray()) {
            for (JsonNode item : node) {
                String v = findAppId(item);
                if (!v.isEmpty()) return v;
            }
        }
        return "";
    }

    private static String nodeToIdString(JsonNode n) {
        if (n == null || n.isMissingNode() || n.isNull()) return "";
        if (n.isTextual() || n.isNumber() || n.isBoolean()) return n.asText();
        if (n.isObject()) {
            for (String idKey : ID_KEYS) {
                JsonNode inner = n.get(idKey);
                if (inner != null && !inner.isNull()) {
                    String v = nodeToIdString(inner);
                    if (!v.isEmpty()) return v;
                }
            }
            Iterator<Map.Entry<String, JsonNode>> it = n.fields();
            while (it.hasNext()) {
                Map.Entry<String, JsonNode> e = it.next();
                String v = nodeToIdString(e.getValue());
                if (!v.isEmpty()) return v;
            }
        }
        if (n.isArray()) {
            for (JsonNode item : n) {
                String v = nodeToIdString(item);
                if (!v.isEmpty()) return v;
            }
        }
        return "";
    }

    private static void writeUnifiedExcel(List<RowData> rows, String excelPath) throws Exception {
        try (Workbook workbook = new XSSFWorkbook();
             FileOutputStream fos = new FileOutputStream(excelPath)) {

            Sheet sheet = workbook.createSheet("AppID Comparison");
            Row header = sheet.createRow(0);
            header.createCell(0).setCellValue("File Name");
            header.createCell(1).setCellValue("Pre-AppID");
            header.createCell(2).setCellValue("Post-AppID");
            header.createCell(3).setCellValue("Category");

            int rowIndex = 1;
            for (RowData rd : rows) {
                Row r = sheet.createRow(rowIndex++);
                r.createCell(0).setCellValue(rd.fileName);
                r.createCell(1).setCellValue(rd.preAppId);
                r.createCell(2).setCellValue(rd.postAppId);
                r.createCell(3).setCellValue(rd.category);
            }
            for (int i = 0; i < 4; i++) sheet.autoSizeColumn(i);
            workbook.write(fos);
        }
    }

    private static boolean selectAdministratorGroup(WebDriver driver, WebDriverWait wait) {
        try {
            System.out.println("Selecting Administrator group...");
            jsSelectByVisibleText(driver, wait, By.id("groups"), ADMIN_GROUP);
            jsClick(driver, wait, By.id("id2"));
            sleepSeconds(3);
            wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("menu-wrapper")));
            wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("menu")));
            System.out.println("Administrator group selected successfully.");
            return true;
        } catch (Exception e) {
            System.err.println("Error selecting Administrator group: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    private static boolean navigateToSearchScreen(WebDriver driver, WebDriverWait wait, CategoryConfig config) {
        try {
            System.out.println("Navigating to search screen: " + String.join(" > ", config.menuPath));
            openMenuAndClick(driver, wait, config.menuPath);
            sleepSeconds(3);
            return true;
        } catch (Exception e) {
            System.err.println("Error navigating to search: " + e.getMessage());
            return false;
        }
    }

    private static List<ApplicationData> readUnifiedExcelFile(String excelPath) {
        List<ApplicationData> applications = new ArrayList<>();
        try (FileInputStream fis = new FileInputStream(excelPath);
             Workbook workbook = new XSSFWorkbook(fis)) {
            Sheet sheet = workbook.getSheetAt(0);
            for (int i = 1; i <= sheet.getLastRowNum(); i++) {
                Row row = sheet.getRow(i);
                if (row == null) continue;
                String fileName = getCellValueAsString(row.getCell(0));
                String preAppId = getCellValueAsString(row.getCell(1));
                String postAppId = getCellValueAsString(row.getCell(2));
                ApplicationData appData = new ApplicationData(fileName, preAppId, postAppId);
                if (appData.isValid()) applications.add(appData);
            }
        } catch (IOException e) {
            System.err.println("Error reading Excel: " + e.getMessage());
        }
        return applications;
    }

    private static String getCellValueAsString(Cell cell) {
        if (cell == null) return null;
        switch (cell.getCellType()) {
            case STRING: return cell.getStringCellValue().trim();
            case NUMERIC:
                double numValue = cell.getNumericCellValue();
                if (numValue == Math.floor(numValue)) return String.valueOf((long) numValue);
                return String.valueOf(numValue);
            case BLANK: return null;
            default: return cell.toString().trim();
        }
    }

    private static boolean performLogin(WebDriver driver, WebDriverWait wait) {
        try {
            System.out.println("Performing login...");
            driver.get(BASE_URL);
            sleepSeconds(3);
            jsType(driver, wait, By.id("idToken1"), USERNAME);
            jsType(driver, wait, By.id("idToken2"), PASSWORD);
            jsClick(driver, wait, By.id("loginButton_0"));
            sleepSeconds(3);
            System.out.println("Login successful.");
            return true;
        } catch (Exception e) {
            System.err.println("Login error: " + e.getMessage());
            return false;
        }
    }

    private static boolean extractBureauDataForApplication(WebDriver driver, WebDriverWait wait,
                                                           String applicationId, String outputPath, String type) {
        try {
            System.out.println("Starting extraction for " + type + " App ID: " + applicationId);
            fillApplicationIdAndSearch(driver, wait, applicationId);
            clickOpenApplicationLink(driver, wait);
            clickViewBureauButton(driver, wait);
            extractBureauData(driver, wait, applicationId, outputPath, type);
            System.out.println("Successfully extracted " + type + " data for: " + applicationId);
            return true;
        } catch (Exception e) {
            System.err.println("Extraction error for " + type + " " + applicationId + ": " + e.getMessage());
            return false;
        }
    }

    private static void fillApplicationIdAndSearch(WebDriver driver, WebDriverWait wait, String applicationId) {
        System.out.println("Filling Application ID: " + applicationId);
        try {
            wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("txt-appid")));
            sleepSeconds(2);
            sendKeysStableForAppId(driver, wait, By.id("txt-appid"), applicationId);
            sleepSeconds(2);
            jsClick(driver, wait, By.id("btn-search"));
            System.out.println("Search button clicked.");
            sleepSeconds(3);
        } catch (Exception e) {
            System.err.println("Error in fillApplicationIdAndSearch: " + e.getMessage());
            throw new RuntimeException("Failed to search for: " + applicationId, e);
        }
    }

    private static void clickOpenApplicationLink(WebDriver driver, WebDriverWait wait) {
        System.out.println("Clicking application link...");
        By linkBy = By.xpath("//table[@id='datagrid']//td//div//center//a");
        retryRun(6, 400, () -> {
            wait.until(ExpectedConditions.presenceOfElementLocated(linkBy));
            sleepSeconds(1);
            jsClick(driver, wait, linkBy);
        });
        sleepSeconds(2);
    }

    private static void clickViewBureauButton(WebDriver driver, WebDriverWait wait) {
        System.out.println("Clicking View Bureau button...");
        By btn = By.xpath("//button[.='View Bureau']");
        jsClick(driver, wait, btn);
        sleepSeconds(2);
    }

    private static void extractBureauData(WebDriver driver, WebDriverWait wait, String applicationId,
                                          String outputPath, String type) throws IOException {
        System.out.println("Extracting bureau data from popup...");
        sleepSeconds(4);

        String mainWindow = driver.getWindowHandle();
        Set<String> allWindows = driver.getWindowHandles();
        String popupWindow = null;
        for (String windowHandle : allWindows) {
            if (!windowHandle.equals(mainWindow)) {
                popupWindow = windowHandle;
                break;
            }
        }
        if (popupWindow == null) throw new RuntimeException("Popup window not found");

        driver.switchTo().window(popupWindow);
        sleepSeconds(3);

        StringBuilder allBureauData = new StringBuilder();
        allBureauData.append("===== BUREAU DATA EXTRACTION =====\n");
        allBureauData.append("Type: ").append(type).append("\n");
        allBureauData.append("Application ID: ").append(applicationId).append("\n");
        allBureauData.append("Extraction Time: ").append(LocalDateTime.now()).append("\n");
        allBureauData.append("==================================\n\n");

        try {
            List<WebElement> requestResponseLinks = findRequestResponseLinks(driver, wait);
            System.out.println("Found " + requestResponseLinks.size() + " request/response links");
            for (int i = 0; i < requestResponseLinks.size(); i++) {
                requestResponseLinks = findRequestResponseLinks(driver, wait);
                if (i < requestResponseLinks.size()) {
                    WebElement link = requestResponseLinks.get(i);
                    String linkText = link.getText();
                    String bureauKey = link.getAttribute("bureaukey");
                    String linkType = link.getAttribute("type");
                    System.out.println("Processing: " + bureauKey + " - " + linkType);

                    allBureauData.append("\n").append("=".repeat(50)).append("\n");
                    allBureauData.append("Bureau: ").append(bureauKey != null ? bureauKey : "Unknown").append("\n");
                    allBureauData.append("Type: ").append(linkType != null ? linkType : linkText).append("\n");
                    allBureauData.append("=".repeat(50)).append("\n");
                    try {
                        scrollIntoViewCenter(driver, link);
                        js(driver).executeScript("arguments[0].click();", link);
                    } catch (StaleElementReferenceException se) {
                        requestResponseLinks = findRequestResponseLinks(driver, wait);
                        if (i < requestResponseLinks.size()) {
                            WebElement link2 = requestResponseLinks.get(i);
                            scrollIntoViewCenter(driver, link2);
                            js(driver).executeScript("arguments[0].click();", link2);
                        }
                    }

                    sleepSeconds(2);
                    Set<String> currentWindows = driver.getWindowHandles();
                    String dataWindow = null;
                    for (String wh : currentWindows) {
                        if (!wh.equals(mainWindow) && !wh.equals(popupWindow)) {
                            dataWindow = wh;
                            break;
                        }
                    }
                    if (dataWindow != null) {
                        driver.switchTo().window(dataWindow);
                        try {
                            WebElement preElement = wait.until(ExpectedConditions.presenceOfElementLocated(By.tagName("pre")));
                            String preContent = preElement.getText();
                            allBureauData.append(preContent).append("\n");
                            System.out.println("Extracted " + preContent.length() + " characters");
                        } catch (Exception e) {
                            String bodyText = driver.findElement(By.tagName("body")).getText();
                            allBureauData.append(bodyText).append("\n");
                            System.out.println("Extracted body text: " + bodyText.length() + " characters");
                        }
                        driver.close();
                        driver.switchTo().window(popupWindow);
                    }
                    sleepSeconds(1);
                }
            }
        } catch (Exception e) {
            System.err.println("Error during data extraction: " + e.getMessage());
            e.printStackTrace();
        }

        try (FileWriter writer = new FileWriter(outputPath)) {
            writer.write(allBureauData.toString());
            System.out.println("Bureau data saved to: " + outputPath);
        }

        driver.close();
        driver.switchTo().window(mainWindow);
    }

    private static void navigateBackToSearch(WebDriver driver, WebDriverWait wait) {
        try {
            System.out.println("Navigating back to search screen...");
            jsClick(driver, wait, By.xpath("//button[.='Close']"));
            sleepSeconds(2);
            handleConfirmationModal(driver, wait);
            wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("txt-appid")));
            sleepSeconds(2);
            System.out.println("Successfully navigated back to search screen.");
        } catch (Exception e) {
            System.err.println("Error navigating back: " + e.getMessage());
            throw new RuntimeException("Failed to navigate back to search", e);
        }
    }

    private static void handleConfirmationModal(WebDriver driver, WebDriverWait wait) {
        try {
            WebElement modal = wait.until(ExpectedConditions.visibilityOfElementLocated(By.cssSelector(".wicket-modal")));
            jsClick(driver, wait, By.xpath("//*[@name='ok']"));
            wait.until(ExpectedConditions.invisibilityOf(modal));
            System.out.println("Confirmation modal handled.");
        } catch (Exception e) {
            try {
                jsClick(driver, wait, By.xpath("//input[@type='button' and @value='OK']"));
                sleepSeconds(2);
            } catch (Exception altError) {
                System.err.println("Modal handling failed: " + altError.getMessage());
                throw e;
            }
        }
    }

    private static String compareFilesWithBureauInfo(String preFilePath, String postFilePath, ApplicationData app) {
        StringBuilder result = new StringBuilder();
        result.append("File: ").append(app.fileName).append("\n");
        try {
            List<String> preLines = Files.readAllLines(Paths.get(preFilePath));
            List<String> postLines = Files.readAllLines(Paths.get(postFilePath));

            List<BureauSection> preSections = parseBureauSections(preLines);
            List<BureauSection> postSections = parseBureauSections(postLines);

            List<String> preNormalized = removeMetadata(normalizeContent(preLines));
            List<String> postNormalized = removeMetadata(normalizeContent(postLines));

            if (preNormalized.equals(postNormalized)) {
                result.append("Status: MATCHED - No differences found");
            } else {
                result.append("Status: DIFFERENCES FOUND\n");
                result.append("Differences Details:\n");
                result.append(findDifferencesWithBureauInfo(preLines, postLines, preSections, postSections));
            }
        } catch (IOException e) {
            result.append("Status: ERROR - Could not compare files\n");
            result.append("Error: ").append(e.getMessage());
        }
        return result.toString();
    }

    private static List<BureauSection> parseBureauSections(List<String> lines) {
        List<BureauSection> sections = new ArrayList<>();
        String currentBureau = "Unknown";
        String currentType = "Unknown";
        int sectionStart = -1;

        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            if (line.startsWith("==================================================")) {
                if (i + 1 < lines.size() && lines.get(i + 1).startsWith("Bureau: ")) {
                    if (sectionStart >= 0) {
                        sections.add(new BureauSection(currentBureau, currentType, sectionStart, i - 1));
                    }
                    currentBureau = lines.get(i + 1).substring("Bureau: ".length()).trim();
                    if (i + 2 < lines.size() && lines.get(i + 2).startsWith("Type: ")) {
                        currentType = lines.get(i + 2).substring("Type: ".length()).trim();
                    }
                    sectionStart = i;
                }
            }
        }
        if (sectionStart >= 0) {
            sections.add(new BureauSection(currentBureau, currentType, sectionStart, lines.size() - 1));
        }
        return sections;
    }

    private static BureauSection findBureauSectionForLine(int lineNum, List<BureauSection> sections) {
        for (BureauSection section : sections) {
            if (lineNum >= section.startLine && lineNum <= section.endLine) {
                return section;
            }
        }
        return null;
    }

    private static String findDifferencesWithBureauInfo(List<String> preLines, List<String> postLines,
                                                        List<BureauSection> preSections,
                                                        List<BureauSection> postSections) {
        StringBuilder diff = new StringBuilder();
        int maxLines = Math.max(preLines.size(), postLines.size());
        int diffCount = 0;
        int displayedDiffs = 0;
        final int MAX_DISPLAY = 20;

        for (int i = 0; i < maxLines; i++) {
            String preLine = i < preLines.size() ? preLines.get(i).trim() : "[MISSING]";
            String postLine = i < postLines.size() ? postLines.get(i).trim() : "[MISSING]";

            if (preLine.isEmpty() && postLine.isEmpty()) continue;
            if (preLine.contains("Extraction Time:") || postLine.contains("Extraction Time:")) continue;
            if (preLine.contains("Application ID:") || postLine.contains("Application ID:")) continue;
            if (preLine.startsWith("Type:") && postLine.startsWith("Type:")) continue;

            if (!preLine.equals(postLine)) {
                diffCount++;
                if (displayedDiffs < MAX_DISPLAY) {
                    BureauSection preSection = findBureauSectionForLine(i, preSections);
                    BureauSection postSection = findBureauSectionForLine(i, postSections);
                    diff.append("\nLine ").append(i + 1).append(":");
                    if (preSection != null) {
                        diff.append(" (Bureau: ").append(preSection.bureauName)
                                .append(", Type: ").append(preSection.type).append(")");
                    } else if (postSection != null) {
                        diff.append(" (Bureau: ").append(postSection.bureauName)
                                .append(", Type: ").append(postSection.type).append(")");
                    }
                    diff.append("\n");
                    String preDisplay = preLine.length() > 100 ? preLine.substring(0, 100) + "..." : preLine;
                    String postDisplay = postLine.length() > 100 ? postLine.substring(0, 100) + "..." : postLine;
                    diff.append(" PRE: ").append(preDisplay).append("\n");
                    diff.append(" POST: ").append(postDisplay).append("\n");
                    displayedDiffs++;
                }
            }
        }
        if (diffCount > MAX_DISPLAY) {
            diff.append("\n... and ").append(diffCount - MAX_DISPLAY).append(" more differences");
        }
        diff.append("\n\nTotal differences found: ").append(diffCount);
        diff.append("\nPre file lines: ").append(preLines.size());
        diff.append("\nPost file lines: ").append(postLines.size());
        return diff.toString();
    }

    private static List<String> normalizeContent(List<String> lines) {
        return lines.stream().map(String::trim).filter(line -> !line.isEmpty()).collect(Collectors.toList());
    }

    private static List<String> removeMetadata(List<String> lines) {
        List<String> filtered = new ArrayList<>();
        boolean skipMetadata = true;
        for (String line : lines) {
            if (skipMetadata && line.contains("==================================")) {
                skipMetadata = false;
                continue;
            }
            if (line.contains("Extraction Time:") || line.contains("Application ID:") || line.startsWith("Type:")) {
                continue;
            }
            if (!skipMetadata) filtered.add(line);
        }
        return filtered;
    }

    private static void expandAllJsTreeNodes(WebDriver driver, WebDriverWait wait) {
        wait.until(ExpectedConditions.presenceOfElementLocated(By.cssSelector(".jstree")));
        JavascriptExecutor je = js(driver);

        try {
            Object usedApi = je.executeScript(
                    "try {" +
                    " if (window.$ && $('.jstree').length && $('.jstree').jstree) {" +
                    "   var inst=$('.jstree').jstree(true) || $('.jstree').jstree();" +
                    "   if (inst && inst.open_all) { inst.open_all(); return true; }" +
                    " }" +
                    "} catch(e){}" +
                    "return false;");
            if (Boolean.TRUE.equals(usedApi)) {
                try { wait.until(d -> driver.findElements(By.cssSelector(".jstree .jstree-loading")).isEmpty()); }
                catch (TimeoutException ignored) {}
                return;
            }
        } catch (Exception ignored) {}

        int safety = 0, maxPasses = 50;
        while (safety++ < maxPasses) {
            List<WebElement> togglers = driver.findElements(By.cssSelector(
                    ".jstree li.jstree-closed > i.jstree-ocl, .jstree li.jstree-closed > i.jstree-icon.jstree-ocl"));
            if (togglers.isEmpty()) break;
            int before = togglers.size();

            for (int idx = 0; idx < togglers.size(); idx++) {
                try {
                    WebElement t = togglers.get(idx);
                    scrollIntoViewCenter(driver, t);
                    je.executeScript("arguments[0].click();", t);
                } catch (StaleElementReferenceException ignored) {
                }
                sleepQuiet(150);
            }

            try {
                wait.until(d -> {
                    int after = driver.findElements(By.cssSelector(
                            ".jstree li.jstree-closed > i.jstree-ocl, .jstree li.jstree-closed > i.jstree-icon.jstree-ocl")).size();
                    return after < before;
                });
            } catch (TimeoutException ignored) {}
        }
    }

    private static List<WebElement> findRequestResponseLinks(WebDriver driver, WebDriverWait wait) {
        List<WebElement> links = new ArrayList<>();
        try {
            wait.until(ExpectedConditions.presenceOfElementLocated(By.className("jstree")));
            expandAllJsTreeNodes(driver, wait);
            List<WebElement> rawLinks = driver.findElements(By.xpath("//a[@raw]"));
            for (WebElement link : rawLinks) {
                try {
                    String type = link.getAttribute("type");
                    if ("request".equals(type) || "response".equals(type)) {
                        links.add(link);
                    }
                } catch (StaleElementReferenceException ignored) {
                }
            }
        } catch (Exception e) {
            System.err.println("Error finding request/response links: " + e.getMessage());
        }
        return links;
    }

    private static void openMenuAndClick(WebDriver driver, WebDriverWait wait, String... labels) {
        if (labels == null || labels.length == 0) {
            throw new IllegalArgumentException("At least one label is required");
        }

        Actions actions = new Actions(driver);
        JavascriptExecutor js = (JavascriptExecutor) driver;

        WebElement scope = wait.until(ExpectedConditions.presenceOfElementLocated(By.cssSelector("ul#menu")));

        for (int i = 0; i < labels.length; i++) {
            String label = labels[i].trim().replaceAll("\\s+", " ");

            String anchorsXpath = scope.getTagName().equalsIgnoreCase("ul") ? "./li/a" : "./ul/li/a";
            List<WebElement> anchors = scope.findElements(By.xpath(anchorsXpath));

            WebElement link = anchors.stream().filter(a -> {
                String direct = (String) js.executeScript(
                        "const a=arguments[0]; return [...a.childNodes].filter(n=>n.nodeType===3)" +
                                ".map(n=>n.textContent).join('').replace(/\\s+/g,' ').trim();",
                        a);
                return label.equals(direct);
            }).findFirst().orElseThrow(() -> new NoSuchElementException("Not found: " + label));

            js.executeScript("arguments[0].scrollIntoView({block:'center'});", link);
            wait.until(ExpectedConditions.visibilityOf(link));

            boolean isLeaf = (i == labels.length - 1);
            if (isLeaf) {
                try {
                    wait.until(ExpectedConditions.elementToBeClickable(link)).click();
                } catch (Exception e) {
                    js.executeScript("arguments[0].click();", link);
                }
                return;
            } else {
                WebElement li = link.findElement(By.xpath("./ancestor::li[1]"));
                boolean opened = false;

                try {
                    actions.moveToElement(link).pause(Duration.ofMillis(150)).perform();
                    opened = waitChildVisibleByJs(driver, li, Duration.ofSeconds(2));
                } catch (Exception ignored) {
                }

                if (!opened) {
                    try {
                        wait.until(ExpectedConditions.elementToBeClickable(link)).click();
                    } catch (Exception e) {
                        js.executeScript("arguments[0].click();", link);
                    }
                    opened = waitChildVisibleByJs(driver, li, Duration.ofSeconds(4));
                }

                if (!opened) {
                    throw new TimeoutException("Submenu did not open for: " + label);
                }
                scope = li;
            }
        }
    }

    private static boolean waitChildVisibleByJs(WebDriver driver, WebElement li, Duration timeout) {
        WebDriverWait w = new WebDriverWait(driver, timeout);
        try {
            return w.until(d -> {
                try {
                    WebElement ul = li.findElement(By.xpath("./ul"));
                    Object visible = js(d).executeScript(
                            "const u=arguments[0]; if(!u) return false;" +
                            "const s=getComputedStyle(u);" +
                            "if(s.display==='none' || s.visibility==='hidden' || +s.opacity===0) return false;" +
                            "const r=u.getBoundingClientRect(); return r.width>0 && r.height>0;", ul);
                    return Boolean.TRUE.equals(visible);
                } catch (NoSuchElementException | StaleElementReferenceException e) {
                    return false;
                }
            });
        } catch (TimeoutException e) {
            return false;
        }
    }

    private static void sleepSeconds(int seconds) {
        try { Thread.sleep(seconds * 1000L); }
        catch (InterruptedException ie) { Thread.currentThread().interrupt(); }
    }
}




run.bat
=============
@echo off
REM ================================================================
REM Bureau Data Extraction and Comparison Tool - Launcher
REM ================================================================
REM This script sets up the environment and runs the tool
REM ================================================================

SETLOCAL EnableDelayedExpansion

echo.
echo ========================================================
echo    Bureau Data Extraction and Comparison Tool
echo ========================================================
echo.

REM Get the directory where this batch file is located
set "APP_DIR=%~dp0"
cd /d "%APP_DIR%"

echo [INFO] Application directory: %APP_DIR%
echo.

REM Check if Java is installed
echo [STEP 1/5] Checking Java installation...
java -version >nul 2>&1
if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Java is not installed or not in PATH!
    echo.
    echo Please install Java JDK 11 or higher and add it to your system PATH.
    echo Download from: https://www.oracle.com/java/technologies/downloads/
    echo.
    pause
    exit /b 1
)
echo [OK] Java is installed
java -version
echo.

REM Check if config.properties exists
echo [STEP 2/5] Checking configuration file...
if not exist "config.properties" (
    echo [ERROR] config.properties not found!
    echo.
    echo Please make sure config.properties is in the same folder as this batch file.
    echo.
    pause
    exit /b 1
)
echo [OK] Configuration file found
echo.

REM Create required folders if they don't exist
echo [STEP 3/5] Setting up folder structure...
if not exist "pre" mkdir pre
if not exist "post" mkdir post
if not exist "comparisons" mkdir comparisons

echo [OK] Folders created:
echo     - pre/       (Place your PRE data files here)
echo     - post/      (Place your POST data files here)
echo     - comparisons/ (Output will be saved here)
echo.

REM Check if JAR file exists
echo [STEP 4/5] Checking application JAR file...
if not exist "BureauComparison.jar" (
    echo [WARNING] BureauComparison.jar not found!
    echo.
    echo The JAR file should be built first. Please build the project or
    echo place the JAR file in this directory.
    echo.
    pause
    exit /b 1
)
echo [OK] JAR file found
echo.

REM Run the application
echo [STEP 5/5] Starting the application...
echo.
echo ========================================================
echo                   APPLICATION STARTING
echo ========================================================
echo.

REM Run with proper memory settings
REM Adjust -Xmx if you need more memory (e.g., -Xmx4g for 4GB)
java -Xmx2g -jar BureauComparison.jar

REM Check exit code
if %ERRORLEVEL% NEQ 0 (
    echo.
    echo [ERROR] Application exited with error code: %ERRORLEVEL%
    echo.
    pause
    exit /b %ERRORLEVEL%
)

echo.
echo ========================================================
echo            APPLICATION COMPLETED SUCCESSFULLY
echo ========================================================
echo.
echo Results have been saved in the 'comparisons' folder
echo.
pause


config.properties
=====================
# Bureau Data Extraction Tool - Configuration File
# This file contains all the configuration settings for the tool

# ===== APPLICATION URL AND CREDENTIALS =====
# Base URL of the web application
base.url=http://usaqwblbcus30.us.experian.eeca:8080/WebEngine/

# Login credentials
username=Harsh
password=Friday@0123!

# Admin group name (used for selecting the appropriate group after login)
admin.group=Administrators

# ===== FOLDER CONFIGURATION =====
# Note: These folders are relative to the application directory (where this file is located)
# The tool will automatically create these folders if they don't exist

# Folder name for PRE data files
pre.folder.name=pre

# Folder name for POST data files
post.folder.name=post

# Folder name for output/comparison results
output.folder.name=comparisons

# ===== BROWSER CONFIGURATION =====
# Total number of browser instances to run in parallel
# Higher numbers = faster processing, but more system resources
# Recommended: 5-15 depending on your system
num.browser.instances=15

# Number of browsers per category (ACQ, CLI, PRQ)
# This determines how many parallel browsers work on each category
browsers.per.category=5

# ===== NOTES =====
# 1. All folder paths are relative to the application directory
# 2. Ensure your system has enough RAM for the configured number of browser instances
# 3. ChromeDriver must be installed and accessible in system PATH
# 4. Place your PRE data files in the 'pre' folder before running
# 5. Place your POST data files in the 'post' folder before running
# 6. Results will be saved in the 'comparisons' folder

build-and-package.bat
@echo off
REM ================================================================
REM Build and Package Script
REM This script builds the JAR and creates a distribution package
REM ================================================================

SETLOCAL EnableDelayedExpansion

echo.
echo ========================================================
echo    Bureau Comparison Tool - Build and Package
echo ========================================================
echo.

REM Check if Maven is installed
echo [1/5] Checking Maven installation...
mvn -version >nul 2>&1
if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Maven is not installed or not in PATH!
    echo.
    echo Please install Apache Maven and add it to your system PATH.
    echo Download from: https://maven.apache.org/download.cgi
    echo.
    pause
    exit /b 1
)
echo [OK] Maven is installed
mvn -version
echo.

REM Check if pom.xml exists
echo [2/5] Checking project files...
if not exist "pom.xml" (
    echo [ERROR] pom.xml not found!
    echo Please run this script from the project root directory.
    pause
    exit /b 1
)
echo [OK] Project files found
echo.

REM Create source directory structure if needed
echo [3/5] Setting up source structure...
if not exist "src\main\java\com\harsha\extractor" mkdir src\main\java\com\harsha\extractor
if not exist "src\main\resources" mkdir src\main\resources

REM Copy source file if it exists in current directory
if exist "ExtractorPortable.java" (
    echo Copying source file to src directory...
    copy /Y "ExtractorPortable.java" "src\main\java\com\harsha\extractor\" >nul
)

echo [OK] Source structure ready
echo.

REM Build the project
echo [4/5] Building the project with Maven...
echo This may take a few minutes on first run...
echo.
call mvn clean package

if %ERRORLEVEL% NEQ 0 (
    echo.
    echo [ERROR] Build failed!
    echo Please check the error messages above.
    pause
    exit /b 1
)
echo.
echo [OK] Build successful!
echo.

REM Create distribution package
echo [5/5] Creating distribution package...

set "DIST_DIR=BureauComparison-Package"
set "TIMESTAMP=%DATE:~-4%%DATE:~4,2%%DATE:~7,2%_%TIME:~0,2%%TIME:~3,2%%TIME:~6,2%"
set "TIMESTAMP=%TIMESTAMP: =0%"

REM Clean and create distribution directory
if exist "%DIST_DIR%" rmdir /s /q "%DIST_DIR%"
mkdir "%DIST_DIR%"
mkdir "%DIST_DIR%\pre"
mkdir "%DIST_DIR%\post"
mkdir "%DIST_DIR%\comparisons"

REM Copy JAR file
echo Copying JAR file...
copy /Y "target\BureauComparison.jar" "%DIST_DIR%\" >nul

REM Copy configuration and scripts
echo Copying configuration files...
copy /Y "config.properties" "%DIST_DIR%\" >nul
copy /Y "run.bat" "%DIST_DIR%\" >nul

REM Copy documentation
if exist "README.md" copy /Y "README.md" "%DIST_DIR%\" >nul

REM Create a sample .env file for ChromeDriver path (optional)
echo # ChromeDriver Path (Optional) > "%DIST_DIR%\.env.example"
echo # Uncomment and set if ChromeDriver is not in system PATH >> "%DIST_DIR%\.env.example"
echo # webdriver.chrome.driver=C:\\path\\to\\chromedriver.exe >> "%DIST_DIR%\.env.example"

REM Create a quick start guide
echo Creating Quick Start Guide... > "%DIST_DIR%\QUICK_START.txt"
echo ======================================== >> "%DIST_DIR%\QUICK_START.txt"
echo   Bureau Comparison Tool - Quick Start >> "%DIST_DIR%\QUICK_START.txt"
echo ======================================== >> "%DIST_DIR%\QUICK_START.txt"
echo. >> "%DIST_DIR%\QUICK_START.txt"
echo 1. Install Java JDK 11 or higher >> "%DIST_DIR%\QUICK_START.txt"
echo 2. Install ChromeDriver matching your Chrome version >> "%DIST_DIR%\QUICK_START.txt"
echo 3. Edit config.properties with your credentials >> "%DIST_DIR%\QUICK_START.txt"
echo 4. Place PRE files in the 'pre' folder >> "%DIST_DIR%\QUICK_START.txt"
echo 5. Place POST files in the 'post' folder >> "%DIST_DIR%\QUICK_START.txt"
echo 6. Double-click run.bat to start >> "%DIST_DIR%\QUICK_START.txt"
echo 7. Results will be in the 'comparisons' folder >> "%DIST_DIR%\QUICK_START.txt"
echo. >> "%DIST_DIR%\QUICK_START.txt"
echo For detailed instructions, see README.md >> "%DIST_DIR%\QUICK_START.txt"

echo.
echo [OK] Distribution package created: %DIST_DIR%
echo.

REM Create ZIP archive if 7-Zip is available
where 7z >nul 2>&1
if %ERRORLEVEL% EQU 0 (
    echo Creating ZIP archive...
    set "ZIP_NAME=BureauComparison-v1.0-%TIMESTAMP%.zip"
    7z a -tzip "!ZIP_NAME!" "%DIST_DIR%\*" >nul
    echo [OK] ZIP archive created: !ZIP_NAME!
) else (
    echo [INFO] 7-Zip not found. Skipping archive creation.
    echo [INFO] You can manually compress the '%DIST_DIR%' folder.
)

echo.
echo ========================================================
echo              BUILD AND PACKAGE COMPLETE!
echo ========================================================
echo.
echo Distribution folder: %DIST_DIR%
echo.
echo You can now:
echo 1. Test locally by running: %DIST_DIR%\run.bat
echo 2. Zip the folder and share with testers
echo 3. Upload to shared drive or repository
echo.
echo Contents:
dir /b "%DIST_DIR%"
echo.
pause


create
+++++++++++++++++
@echo off
REM ================================================================
REM Project Structure Creator
REM This script creates the required folder structure for building
REM ================================================================

echo.
echo ========================================================
echo    Creating Project Structure
echo ========================================================
echo.

REM Prompt for project directory
set /p PROJECT_DIR="Enter the full path where you want to create the project (e.g., C:\BureauProject): "

REM Remove trailing backslash if present
if "%PROJECT_DIR:~-1%" == "\" set PROJECT_DIR=%PROJECT_DIR:~0,-1%

echo.
echo Creating project at: %PROJECT_DIR%
echo.

REM Create project directory
if not exist "%PROJECT_DIR%" (
    mkdir "%PROJECT_DIR%"
    echo [OK] Created project directory
) else (
    echo [INFO] Project directory already exists
)

REM Create Maven directory structure
echo Creating Maven directory structure...

mkdir "%PROJECT_DIR%\src\main\java\com\harsha\extractor" 2>nul
mkdir "%PROJECT_DIR%\src\main\resources" 2>nul
mkdir "%PROJECT_DIR%\src\test\java" 2>nul
mkdir "%PROJECT_DIR%\target" 2>nul

echo [OK] Maven structure created
echo.

REM Get the directory where this batch file is located
set "SCRIPT_DIR=%~dp0"

REM Copy files if they exist in the same directory as this script
echo Copying project files...

if exist "%SCRIPT_DIR%ExtractorPortable.java" (
    copy "%SCRIPT_DIR%ExtractorPortable.java" "%PROJECT_DIR%\src\main\java\com\harsha\extractor\" >nul 2>&1
    echo [OK] Copied ExtractorPortable.java
) else (
    echo [SKIP] ExtractorPortable.java not found in current directory
)

if exist "%SCRIPT_DIR%pom.xml" (
    copy "%SCRIPT_DIR%pom.xml" "%PROJECT_DIR%\" >nul 2>&1
    echo [OK] Copied pom.xml
) else (
    echo [SKIP] pom.xml not found
)

if exist "%SCRIPT_DIR%config.properties" (
    copy "%SCRIPT_DIR%config.properties" "%PROJECT_DIR%\" >nul 2>&1
    echo [OK] Copied config.properties
) else (
    echo [SKIP] config.properties not found
)

if exist "%SCRIPT_DIR%run.bat" (
    copy "%SCRIPT_DIR%run.bat" "%PROJECT_DIR%\" >nul 2>&1
    echo [OK] Copied run.bat
) else (
    echo [SKIP] run.bat not found
)

if exist "%SCRIPT_DIR%build-and-package.bat" (
    copy "%SCRIPT_DIR%build-and-package.bat" "%PROJECT_DIR%\" >nul 2>&1
    echo [OK] Copied build-and-package.bat
) else (
    echo [SKIP] build-and-package.bat not found
)

if exist "%SCRIPT_DIR%README.md" (
    copy "%SCRIPT_DIR%README.md" "%PROJECT_DIR%\" >nul 2>&1
    echo [OK] Copied README.md
) else (
    echo [SKIP] README.md not found
)

echo.
echo ========================================================
echo            Project Structure Created!
echo ========================================================
echo.
echo Location: %PROJECT_DIR%
echo.
echo Structure:
echo %PROJECT_DIR%\
echo ‚îú‚îÄ‚îÄ src\
echo ‚îÇ   ‚îî‚îÄ‚îÄ main\
echo ‚îÇ       ‚îú‚îÄ‚îÄ java\
echo ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ com\
echo ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ harsha\
echo ‚îÇ       ‚îÇ           ‚îî‚îÄ‚îÄ extractor\
echo ‚îÇ       ‚îÇ               ‚îî‚îÄ‚îÄ ExtractorPortable.java
echo ‚îÇ       ‚îî‚îÄ‚îÄ resources\
echo ‚îú‚îÄ‚îÄ pom.xml
echo ‚îú‚îÄ‚îÄ config.properties
echo ‚îú‚îÄ‚îÄ run.bat
echo ‚îú‚îÄ‚îÄ build-and-package.bat
echo ‚îî‚îÄ‚îÄ README.md
echo.
echo Next Steps:
echo 1. Navigate to: %PROJECT_DIR%
echo 2. Verify all files are copied
echo 3. Run: build-and-package.bat
echo.
echo Opening project directory...
start explorer "%PROJECT_DIR%"
echo.
pause



<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.harsha</groupId>
    <artifactId>bureau-comparison</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <name>Bureau Data Comparison Tool</name>
    <description>Automated tool for extracting and comparing bureau data</description>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <selenium.version>4.15.0</selenium.version>
        <poi.version>5.2.5</poi.version>
        <jackson.version>2.16.0</jackson.version>
    </properties>

    <dependencies>
        <!-- Selenium WebDriver -->
        <dependency>
            <groupId>org.seleniumhq.selenium</groupId>
            <artifactId>selenium-java</artifactId>
            <version>${selenium.version}</version>
        </dependency>

        <dependency>
            <groupId>org.seleniumhq.selenium</groupId>
            <artifactId>selenium-chrome-driver</artifactId>
            <version>${selenium.version}</version>
        </dependency>

        <!-- Apache POI for Excel -->
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
            <version>${poi.version}</version>
        </dependency>

        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>${poi.version}</version>
        </dependency>

        <!-- Jackson for JSON -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>${jackson.version}</version>
        </dependency>

        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-core</artifactId>
            <version>${jackson.version}</version>
        </dependency>

        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-annotations</artifactId>
            <version>${jackson.version}</version>
        </dependency>

        <!-- SLF4J for logging (required by Selenium) -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.9</version>
        </dependency>

        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-simple</artifactId>
            <version>2.0.9</version>
        </dependency>
    </dependencies>

    <build>
        <finalName>BureauComparison</finalName>
        <plugins>
            <!-- Maven Compiler Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                </configuration>
            </plugin>

            <!-- Maven Assembly Plugin - Creates JAR with all dependencies -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-assembly-plugin</artifactId>
                <version>3.6.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <mainClass>com.harsha.extractor.ExtractorPortable</mainClass>
                            <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
                            <addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>
                        </manifest>
                    </archive>
                    <descriptorRefs>
                        <descriptorRef>jar-with-dependencies</descriptorRef>
                    </descriptorRefs>
                    <appendAssemblyId>false</appendAssemblyId>
                </configuration>
                <executions>
                    <execution>
                        <id>make-assembly</id>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- Maven Jar Plugin - Backup option -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <mainClass>com.harsha.extractor.ExtractorPortable</mainClass>
                            <addClasspath>true</addClasspath>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
