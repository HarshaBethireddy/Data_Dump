import pandas as pd
import re
from z3 import *
from pyparsing import (
    Word, alphas, nums, alphanums, Literal, Group, Optional, 
    infixNotation, opAssoc, ParseException, Suppress, QuotedString,
    CaselessKeyword, pyparsing_common, Regex
)

# Configuration ===========================================
RULES_FILE = "C:\\Users\\C24692E\\Downloads\\PolicyRules.xlsx"
ORDER_FILE = "C:\\Users\\C24692E\\Downloads\\PolicyOrder.xlsx"
OUTPUT_TEMPLATE = "C:\\Users\\C24692E\\Downloads\\input.xlsx"

# 1. Z3 Variable Management ==============================
z3_vars = {}

def get_z3_var(name, var_type='int'):
    """Create or retrieve Z3 variable dynamically"""
    if name not in z3_vars:
        if var_type == 'string':
            z3_vars[name] = String(name)
        elif var_type == 'real':
            z3_vars[name] = Real(name)
        else:
            z3_vars[name] = Int(name)
    return z3_vars[name]

def normalize_var_name(raw_name):
    """
    Convert any Excel variable format to clean Z3 variable name
    Examples:
        'WS.riskModel[1].FICO-Score-10-T' â†’ WS_riskModel_FICO_Score_10_T
        Attr.Val â†’ Attr_Val
        Prm.15017 â†’ Prm_15017
    """
    clean = str(raw_name).strip()
    # Remove quotes
    clean = clean.replace("'", "").replace('"', '')
    # Remove array indices
    clean = re.sub(r'\[(\d+)\]', r'_\1', clean)
    # Replace dots with underscores
    clean = clean.replace('.', '_')
    # Replace hyphens with underscores
    clean = clean.replace('-', '_')
    return clean

# 2. GRAMMAR DEFINITION (pyparsing) ==============================

# Define tokens
LPAREN = Suppress("(")
RPAREN = Suppress(")")

# Variable: Can be quoted or unquoted, contains dots, brackets, hyphens
# Examples: 'WS.riskModel[1].FICO-Score-10-T', Attr.Val, Prm.15017
var_quoted = QuotedString("'") | QuotedString('"')
var_unquoted = Regex(r"[A-Za-z_][\w\.\[\]\-]*")
variable = var_quoted | var_unquoted

# Numbers: integers or floats
number = pyparsing_common.number()

# String literals (for string comparisons)
string_literal = QuotedString("'") | QuotedString('"')

# Comparison operators
comp_op = (
    Literal(">=") | Literal("<=") | Literal("!=") | 
    Literal(">") | Literal("<") | Literal("==") | Literal("=")
)

# Logical operators
AND = CaselessKeyword("and")
OR = CaselessKeyword("or")
NOT = CaselessKeyword("not")

# Forward declaration for recursive grammar
expr = None

# Comparison expression: var op value
# Examples: Score >= 600, LoanType = "Card", Attr.Val < 12
comparison = Group(
    variable("var") + comp_op("op") + (number | string_literal | variable)("value")
)

# Chained comparison: var op1 value1 and op2 value2
# Examples: Score >= 627 and <= 638
chained_comparison = Group(
    variable("var") + 
    comp_op("op1") + 
    number("val1") + 
    (AND | OR)("conj") + 
    comp_op("op2") + 
    number("val2")
)

# Base expression
base_expr = chained_comparison | comparison | Group(LPAREN + expr + RPAREN)

# Recursive definition with operator precedence
expr <<= infixNotation(
    base_expr,
    [
        (NOT, 1, opAssoc.RIGHT),     # NOT has highest precedence
        (AND, 2, opAssoc.LEFT),       # AND before OR
        (OR, 2, opAssoc.LEFT),        # OR has lowest precedence
    ]
)

# Complete rule (with optional outer parentheses)
rule = Optional(LPAREN) + expr + Optional(RPAREN)

# 3. PARSE TREE TO Z3 CONVERTER ==============================

def parse_tree_to_z3(parse_result):
    """
    Recursively convert pyparsing parse tree to Z3 constraint
    """
    if not parse_result:
        return None
    
    # If it's a list, process based on structure
    if isinstance(parse_result, list):
        if len(parse_result) == 0:
            return None
        
        # Single element - recurse
        if len(parse_result) == 1:
            return parse_tree_to_z3(parse_result[0])
        
        # Check if it's a boolean operation [expr, 'and'/'or', expr]
        # OR [expr, 'and'/'or', expr, 'and'/'or', expr, ...]
        if len(parse_result) >= 3:
            # Look for 'and' or 'or' operators
            ops = []
            operands = []
            
            i = 0
            while i < len(parse_result):
                if i == 0:
                    operands.append(parse_tree_to_z3(parse_result[i]))
                    i += 1
                elif isinstance(parse_result[i], str) and parse_result[i].lower() in ['and', 'or']:
                    ops.append(parse_result[i].lower())
                    i += 1
                    if i < len(parse_result):
                        operands.append(parse_tree_to_z3(parse_result[i]))
                        i += 1
                else:
                    # It's a grouped expression
                    operands.append(parse_tree_to_z3(parse_result[i]))
                    i += 1
            
            # Combine operands with operators
            if len(operands) == 1:
                return operands[0]
            
            # Apply operators left to right (already handled by grammar precedence)
            result = operands[0]
            for i, op in enumerate(ops):
                if op == 'and':
                    result = And(result, operands[i + 1])
                elif op == 'or':
                    result = Or(result, operands[i + 1])
            
            return result
    
    # Check if it's a NOT operation
    if isinstance(parse_result, list) and len(parse_result) == 2:
        if isinstance(parse_result[0], str) and parse_result[0].lower() == 'not':
            return Not(parse_tree_to_z3(parse_result[1]))
    
    # Check if it's a parsed comparison group
    if hasattr(parse_result, 'asDict'):
        d = parse_result.asDict()
        
        # Chained comparison: var >= 627 and <= 638
        if 'var' in d and 'op1' in d and 'op2' in d:
            var_name = normalize_var_name(d['var'])
            op1 = d['op1']
            val1 = d['val1']
            conj = d['conj'].lower()
            op2 = d['op2']
            val2 = d['val2']
            
            # Determine variable type
            var_type = 'real' if isinstance(val1, float) or isinstance(val2, float) else 'int'
            z3_var = get_z3_var(var_name, var_type)
            
            # Build conditions
            cond1 = build_comparison(z3_var, op1, val1)
            cond2 = build_comparison(z3_var, op2, val2)
            
            if conj == 'and':
                return And(cond1, cond2)
            else:
                return Or(cond1, cond2)
        
        # Simple comparison: var op value
        elif 'var' in d and 'op' in d and 'value' in d:
            var_name = normalize_var_name(d['var'])
            op = d['op']
            value = d['value']
            
            # Determine types
            if isinstance(value, str):
                z3_var = get_z3_var(var_name, 'string')
                z3_value = StringVal(value)
            elif isinstance(value, float):
                z3_var = get_z3_var(var_name, 'real')
                z3_value = RealVal(value)
            else:
                z3_var = get_z3_var(var_name, 'int')
                z3_value = IntVal(value)
            
            return build_comparison(z3_var, op, z3_value)
    
    # Fallback: if it's a single item, try to process it
    return parse_tree_to_z3(parse_result[0]) if isinstance(parse_result, list) else None

def build_comparison(z3_var, op, value):
    """Build Z3 comparison based on operator"""
    if isinstance(value, (int, float)):
        value = IntVal(value) if isinstance(value, int) else RealVal(value)
    
    if op == '>':
        return z3_var > value
    elif op == '>=':
        return z3_var >= value
    elif op == '<':
        return z3_var < value
    elif op == '<=':
        return z3_var <= value
    elif op in ['=', '==']:
        return z3_var == value
    elif op == '!=':
        return z3_var != value
    else:
        raise ValueError(f"Unknown operator: {op}")

# 4. MAIN PARSER FUNCTION ==============================

def parse_rule_to_z3(rule_string):
    """
    Parse Excel rule directly to Z3 constraint
    No preprocessing needed!
    """
    if pd.isna(rule_string) or str(rule_string).strip() == "":
        return None
    
    rule_str = str(rule_string).strip()
    
    try:
        # Parse using grammar
        parse_result = rule.parseString(rule_str, parseAll=True)
        
        # Convert to Z3
        z3_constraint = parse_tree_to_z3(parse_result)
        
        return z3_constraint
    
    except ParseException as e:
        print(f"  âš ï¸  Parse error: {rule_string}")
        print(f"     Error at position {e.loc}: {e.msg}")
        return None
    
    except Exception as e:
        print(f"  âš ï¸  Error parsing: {rule_string}")
        print(f"     {type(e).__name__}: {e}")
        return None

# 5. Read & Build Rules ========================================
print("="*60)
print("ENTERPRISE-GRADE Z3 SOLVER (pyparsing)")
print("="*60)
print("\nReading Excel files...")

try:
    rules_df = pd.read_excel(RULES_FILE)
    order_df = pd.read_excel(ORDER_FILE)
    template_df = pd.read_excel(OUTPUT_TEMPLATE)
    required_headers = template_df.columns.tolist()
except Exception as e:
    print(f"âŒ Error reading files: {e}")
    exit(1)

print(f"âœ“ Rules file: {len(rules_df)} rows")
print(f"âœ“ Order file: {len(order_df)} policies")
print(f"âœ“ Template: {len(required_headers)} columns")

policy_logic_map = {}
current_policy_name = None
current_expressions = []
current_conjugations = []

print("\n" + "="*60)
print("Building Policy Logic Map...")
print("="*60)

for index, row in rules_df.iterrows():
    try:
        p_name = row.iloc[0]
        rule_def = row.iloc[1]
        conjugation = str(row.iloc[2]).strip().upper() if pd.notna(row.iloc[2]) else 'AND'
    except Exception as e:
        print(f"âš ï¸  Error reading row {index}: {e}")
        continue

    # New policy detected
    if pd.notna(p_name) and str(p_name).strip() != "":
        # Save previous policy
        if current_policy_name and current_expressions:
            combined_logic = current_expressions[0]
            for i in range(1, len(current_expressions)):
                prev_conj = current_conjugations[i-1]
                if prev_conj == 'OR':
                    combined_logic = Or(combined_logic, current_expressions[i])
                else:
                    combined_logic = And(combined_logic, current_expressions[i])
            
            policy_logic_map[current_policy_name] = combined_logic
            print(f"âœ“ {current_policy_name}: {len(current_expressions)} rules")
        
        # Start new policy
        current_policy_name = str(p_name).strip()
        current_expressions = []
        current_conjugations = []
    
    # Parse rule
    if pd.notna(rule_def):
        z3_rule = parse_rule_to_z3(rule_def)
        if z3_rule is not None:
            current_expressions.append(z3_rule)
            current_conjugations.append(conjugation)

# Save last policy
if current_policy_name and current_expressions:
    combined_logic = current_expressions[0]
    for i in range(1, len(current_expressions)):
        prev_conj = current_conjugations[i-1]
        if prev_conj == 'OR':
            combined_logic = Or(combined_logic, current_expressions[i])
        else:
            combined_logic = And(combined_logic, current_expressions[i])
    policy_logic_map[current_policy_name] = combined_logic
    print(f"âœ“ {current_policy_name}: {len(current_expressions)} rules")

print(f"\nâœ“ Total policies built: {len(policy_logic_map)}")
print(f"âœ“ Z3 variables: {len(z3_vars)}")
if z3_vars:
    print(f"  Variables: {list(z3_vars.keys())[:10]}...")

# 6. Solve & Generate Data ==============================================
print("\n" + "="*60)
print("Solving Constraints (Waterfall Logic)")
print("="*60)

solver = Solver()
generated_rows = []
previous_policies = []

for index, row in order_df.iterrows():
    try:
        target_policy = str(row.iloc[0]).strip()
    except:
        continue
    
    print(f"\n[{index+1}/{len(order_df)}] {target_policy}")
    solver.reset()

    if target_policy in policy_logic_map:
        # Target policy = TRUE
        solver.add(policy_logic_map[target_policy])
        
        # All previous policies = FALSE
        for prev_pol in previous_policies:
            if prev_pol in policy_logic_map:
                solver.add(Not(policy_logic_map[prev_pol]))
        
        check_result = solver.check()
        
        if check_result == sat:
            model = solver.model()
            new_row = {'Target_Policy_Name': target_policy}
            
            # Map Z3 variables to template headers
            for header in required_headers:
                norm_header = normalize_var_name(header)
                
                matched = False
                for z3_var_name, z3_var in z3_vars.items():
                    if norm_header == z3_var_name or \
                       norm_header in z3_var_name or \
                       z3_var_name in norm_header:
                        
                        val = model[z3_var]
                        if val is not None:
                            try:
                                if is_int(z3_var):
                                    new_row[header] = val.as_long()
                                elif is_real(z3_var):
                                    new_row[header] = float(str(val))
                                elif is_string(z3_var):
                                    new_row[header] = str(val).strip('"')
                                else:
                                    new_row[header] = str(val)
                                matched = True
                                break
                            except:
                                pass
                
                if not matched:
                    new_row[header] = 0
            
            generated_rows.append(new_row)
            previous_policies.append(target_policy)
            print(f"  âœ… SUCCESS")
        
        else:
            print(f"  âŒ UNSAT")
            previous_policies.append(target_policy)
    else:
        print(f"  âš ï¸  Not found in rules")

# 7. Export ==========================================================
print("\n" + "="*60)
print("Export Results")
print("="*60)

if generated_rows:
    final_df = pd.DataFrame(generated_rows)
    final_df.to_excel("Filled_Test_Data.xlsx", index=False)
    print(f"âœ… Generated {len(generated_rows)} test rows")
    print(f"ðŸ“„ Output: Filled_Test_Data.xlsx")
else:
    print("âŒ No data generated")

print("\n" + "="*60)
print("COMPLETE")
print("="*60)
