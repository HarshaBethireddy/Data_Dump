import pandas as pd
import re
from z3 import *

# Configuration ===========================================
RULES_FILE = "C:\\Users\\C24692E\\Downloads\\PolicyRules.xlsx"
ORDER_FILE = "C:\\Users\\C24692E\\Downloads\\PolicyOrder.xlsx"
OUTPUT_TEMPLATE = "C:\\Users\\C24692E\\Downloads\\input.xlsx"

# 1. Z3 Variable Management ==============================
z3_vars = {}

def get_z3_var(name, var_type='int'):
    """Create or retrieve Z3 variable dynamically"""
    if name not in z3_vars:
        if var_type == 'string':
            z3_vars[name] = String(name)
        elif var_type == 'real':
            z3_vars[name] = Real(name)
        else:
            z3_vars[name] = Int(name)
    return z3_vars[name]

def normalize_var_name(raw_name):
    """
    Convert any Excel variable format to clean Z3 variable name
    Examples:
        'WS.riskModel[1].FICO-Score-10-T' â†’ WS_riskModel_1_FICO_Score_10_T
        Attr.Val â†’ Attr_Val
        Prm.15017 â†’ Prm_15017
    """
    clean = str(raw_name).strip()
    # Remove quotes
    clean = clean.replace("'", "").replace('"', '')
    # Replace array indices: [1] â†’ _1
    clean = re.sub(r'\[(\d+)\]', r'_\1', clean)
    # Replace dots with underscores
    clean = clean.replace('.', '_')
    # Replace hyphens with underscores
    clean = clean.replace('-', '_')
    return clean

# 2. ROBUST REGEX-BASED PARSER ==============================

class RuleParser:
    """
    Robust parser for Excel rule syntax
    Handles all common patterns without external dependencies
    """
    
    def __init__(self, rule_string):
        self.original = str(rule_string).strip()
        self.text = self.original
        # Remove outer parentheses
        if self.text.startswith('(') and self.text.endswith(')'):
            self.text = self.text[1:-1].strip()
    
    def parse(self):
        """Main entry point"""
        try:
            return self.parse_or_expression()
        except Exception as e:
            print(f"  âš ï¸  Error parsing: {self.original}")
            print(f"     {e}")
            return None
    
    def parse_or_expression(self):
        """Handle OR at the top level"""
        # Split by 'or' (case insensitive, word boundary)
        parts = re.split(r'\s+or\s+', self.text, flags=re.IGNORECASE)
        
        if len(parts) > 1:
            # Check if this is a chained OR comparison: var < 12 or > 50
            if self.is_chained_or_comparison(parts):
                return self.parse_chained_or_comparison(parts)
            
            # Otherwise, treat as separate OR conditions
            conditions = []
            for part in parts:
                parser = RuleParser(part)
                cond = parser.parse_and_expression()
                if cond:
                    conditions.append(cond)
            
            if len(conditions) == 0:
                return None
            elif len(conditions) == 1:
                return conditions[0]
            else:
                return Or(*conditions)
        else:
            return self.parse_and_expression()
    
    def parse_and_expression(self):
        """Handle AND expressions"""
        # Split by 'and' (case insensitive, word boundary)
        parts = re.split(r'\s+and\s+', self.text, flags=re.IGNORECASE)
        
        if len(parts) > 1:
            # Check if this is a chained comparison: var >= 627 and <= 638
            if self.is_chained_comparison(parts):
                return self.parse_chained_comparison(parts)
            
            # Otherwise, treat as separate AND conditions
            conditions = []
            for part in parts:
                parser = RuleParser(part)
                cond = parser.parse_comparison()
                if cond:
                    conditions.append(cond)
            
            if len(conditions) == 0:
                return None
            elif len(conditions) == 1:
                return conditions[0]
            else:
                return And(*conditions)
        else:
            return self.parse_comparison()
    
    def is_chained_comparison(self, parts):
        """
        Check if this is a chained AND comparison like: var >= 627 and <= 638
        Returns True if second part starts with a comparison operator
        """
        if len(parts) != 2:
            return False
        
        second_part = parts[1].strip()
        # Check if it starts with an operator (no variable name)
        if re.match(r'^\s*(>=|<=|>|<|!=|==|=)\s*', second_part):
            return True
        return False
    
    def is_chained_or_comparison(self, parts):
        """
        Check if this is a chained OR comparison like: var < 12 or > 50
        Returns True if at least one part after the first starts with an operator
        """
        if len(parts) < 2:
            return False
        
        # Check if any part after the first starts with an operator
        for i in range(1, len(parts)):
            part = parts[i].strip()
            if re.match(r'^\s*(>=|<=|>|<|!=|==|=)\s*', part):
                return True
        return False
    
    def parse_chained_or_comparison(self, parts):
        """
        Parse chained OR comparison: var < 12 or > 50 or <= 5
        Handles multiple OR conditions with the same variable
        """
        # First part: extract variable, operator, value
        match1 = re.match(r"(['\"]?[\w\.\[\]\-]+['\"]?)\s*(>=|<=|>|<|!=|==|=)\s*([0-9.]+)", parts[0].strip())
        if not match1:
            return None
        
        var_raw, op1, val1 = match1.groups()
        var_name = normalize_var_name(var_raw)
        
        # Determine type from first value
        var_type = 'real' if '.' in val1 else 'int'
        z3_var = get_z3_var(var_name, var_type)
        
        val1 = float(val1) if '.' in val1 else int(val1)
        
        # Build first condition
        conditions = [self.build_z3_comparison(z3_var, op1, val1)]
        
        # Process remaining parts
        for i in range(1, len(parts)):
            part = parts[i].strip()
            
            # Check if it's operator + value (chained) or full comparison
            match_chained = re.match(r"(>=|<=|>|<|!=|==|=)\s*([0-9.]+)", part)
            
            if match_chained:
                # Chained: same variable
                op, val_str = match_chained.groups()
                val = float(val_str) if '.' in val_str else int(val_str)
                conditions.append(self.build_z3_comparison(z3_var, op, val))
            else:
                # Full comparison: parse recursively
                parser = RuleParser(part)
                cond = parser.parse_comparison()
                if cond:
                    conditions.append(cond)
        
        if len(conditions) == 0:
            return None
        elif len(conditions) == 1:
            return conditions[0]
        else:
            return Or(*conditions)
    
    def parse_chained_comparison(self, parts):
        """
        Parse chained AND comparison: var >= 627 and <= 638
        Can handle multiple ANDs: var >= 500 and <= 600 and != 550
        """
        # First part: extract variable, operator, value
        match1 = re.match(r"(['\"]?[\w\.\[\]\-]+['\"]?)\s*(>=|<=|>|<|!=|==|=)\s*([0-9.]+)", parts[0].strip())
        if not match1:
            return None
        
        var_raw, op1, val1 = match1.groups()
        var_name = normalize_var_name(var_raw)
        
        # Determine type
        var_type = 'real' if '.' in val1 else 'int'
        z3_var = get_z3_var(var_name, var_type)
        
        val1 = float(val1) if '.' in val1 else int(val1)
        
        # Build first condition
        conditions = [self.build_z3_comparison(z3_var, op1, val1)]
        
        # Process remaining parts (all should be operator + value)
        for i in range(1, len(parts)):
            part = parts[i].strip()
            
            match = re.match(r"(>=|<=|>|<|!=|==|=)\s*([0-9.]+)", part)
            if not match:
                return None
            
            op, val_str = match.groups()
            val = float(val_str) if '.' in val_str else int(val_str)
            
            conditions.append(self.build_z3_comparison(z3_var, op, val))
        
        if len(conditions) == 0:
            return None
        elif len(conditions) == 1:
            return conditions[0]
        else:
            return And(*conditions)
    
    def parse_comparison(self):
        """Parse a single comparison"""
        # Pattern: variable operator value
        # Handle quoted variables and string values
        
        # Try numeric comparison first
        pattern_num = r"(['\"]?[\w\.\[\]\-]+['\"]?)\s*(>=|<=|>|<|!=|==|=)\s*([0-9.]+)"
        match = re.match(pattern_num, self.text.strip())
        
        if match:
            var_raw, op, val_str = match.groups()
            var_name = normalize_var_name(var_raw)
            
            # Determine type
            if '.' in val_str:
                z3_var = get_z3_var(var_name, 'real')
                value = float(val_str)
            else:
                z3_var = get_z3_var(var_name, 'int')
                value = int(val_str)
            
            return self.build_z3_comparison(z3_var, op, value)
        
        # Try string comparison
        pattern_str = r"(['\"]?[\w\.\[\]\-]+['\"]?)\s*(=|!=)\s*['\"]([^'\"]+)['\"]"
        match = re.match(pattern_str, self.text.strip())
        
        if match:
            var_raw, op, val_str = match.groups()
            var_name = normalize_var_name(var_raw)
            
            z3_var = get_z3_var(var_name, 'string')
            value = StringVal(val_str)
            
            return self.build_z3_comparison(z3_var, op, value)
        
        return None
    
    def build_z3_comparison(self, z3_var, op, value):
        """Build Z3 comparison constraint"""
        # Normalize single = to ==
        if op == '=':
            op = '=='
        
        if isinstance(value, (int, float)):
            if isinstance(value, float):
                value = RealVal(value)
            else:
                value = IntVal(value)
        
        if op == '>':
            return z3_var > value
        elif op == '>=':
            return z3_var >= value
        elif op == '<':
            return z3_var < value
        elif op == '<=':
            return z3_var <= value
        elif op == '==':
            return z3_var == value
        elif op == '!=':
            return z3_var != value
        else:
            raise ValueError(f"Unknown operator: {op}")

def parse_rule_to_z3(rule_string):
    """
    Parse Excel rule to Z3 constraint
    """
    if pd.isna(rule_string) or str(rule_string).strip() == "":
        return None
    
    parser = RuleParser(rule_string)
    return parser.parse()

# 3. Read & Build Rules ========================================
print("="*60)
print("ENTERPRISE-GRADE Z3 SOLVER")
print("="*60)

# COMPREHENSIVE PATTERN TESTING
print("\n" + "="*60)
print("Testing Pattern Support...")
print("="*60)

test_patterns = [
    "Attr.Val < 12",
    "Attr.Val < 12 or > 50",
    "Attr.Val < 12 or > 50 or = 25",
    "Prm.15017 >= 519 and <= 556",
    "Score >= 600 and <= 700 and != 650",
    "('WS.riskModel[1].'FICO-Score-10-T' >= 627 and <= 638)",
    "Type = 'CreditCard'",
    "Age > 18 and < 65",
    "Amount >= 1000 or Amount <= 100",
]

print("\nTesting rule patterns:")
for pattern in test_patterns:
    parser = RuleParser(pattern)
    result = parser.parse()
    status = "âœ“" if result is not None else "âœ—"
    print(f"  {status} {pattern}")
    if result is None:
        print(f"     ERROR: Failed to parse")

print("\n" + "="*60)

print("\nReading Excel files...")

try:
    rules_df = pd.read_excel(RULES_FILE)
    order_df = pd.read_excel(ORDER_FILE)
    template_df = pd.read_excel(OUTPUT_TEMPLATE)
    required_headers = template_df.columns.tolist()
except Exception as e:
    print(f"âŒ Error reading files: {e}")
    exit(1)

print(f"âœ“ Rules file: {len(rules_df)} rows")
print(f"âœ“ Order file: {len(order_df)} policies")
print(f"âœ“ Template: {len(required_headers)} columns")

policy_logic_map = {}
current_policy_name = None
current_expressions = []
current_conjugations = []

print("\n" + "="*60)
print("Building Policy Logic Map...")
print("="*60)

for index, row in rules_df.iterrows():
    try:
        p_name = row.iloc[0]
        rule_def = row.iloc[1]
        conjugation = str(row.iloc[2]).strip().upper() if pd.notna(row.iloc[2]) else 'AND'
    except Exception as e:
        print(f"âš ï¸  Error reading row {index}: {e}")
        continue

    # New policy detected
    if pd.notna(p_name) and str(p_name).strip() != "":
        # Save previous policy
        if current_policy_name and current_expressions:
            combined_logic = current_expressions[0]
            for i in range(1, len(current_expressions)):
                prev_conj = current_conjugations[i-1]
                if prev_conj == 'OR':
                    combined_logic = Or(combined_logic, current_expressions[i])
                else:
                    combined_logic = And(combined_logic, current_expressions[i])
            
            policy_logic_map[current_policy_name] = combined_logic
            print(f"âœ“ {current_policy_name}: {len(current_expressions)} rules")
        
        # Start new policy
        current_policy_name = str(p_name).strip()
        current_expressions = []
        current_conjugations = []
    
    # Parse rule
    if pd.notna(rule_def):
        z3_rule = parse_rule_to_z3(rule_def)
        if z3_rule is not None:
            current_expressions.append(z3_rule)
            current_conjugations.append(conjugation)

# Save last policy
if current_policy_name and current_expressions:
    combined_logic = current_expressions[0]
    for i in range(1, len(current_expressions)):
        prev_conj = current_conjugations[i-1]
        if prev_conj == 'OR':
            combined_logic = Or(combined_logic, current_expressions[i])
        else:
            combined_logic = And(combined_logic, current_expressions[i])
    policy_logic_map[current_policy_name] = combined_logic
    print(f"âœ“ {current_policy_name}: {len(current_expressions)} rules")

print(f"\nâœ“ Total policies built: {len(policy_logic_map)}")
print(f"âœ“ Z3 variables: {len(z3_vars)}")
if z3_vars:
    print(f"  Variables: {list(z3_vars.keys())}")

# 4. Solve & Generate Data ==============================================
print("\n" + "="*60)
print("Solving Constraints (Waterfall Logic)")
print("="*60)

solver = Solver()
generated_rows = []
previous_policies = []

for index, row in order_df.iterrows():
    try:
        target_policy = str(row.iloc[0]).strip()
    except:
        continue
    
    print(f"\n[{index+1}/{len(order_df)}] {target_policy}")
    solver.reset()

    if target_policy in policy_logic_map:
        # Target policy = TRUE
        solver.add(policy_logic_map[target_policy])
        
        # All previous policies = FALSE
        for prev_pol in previous_policies:
            if prev_pol in policy_logic_map:
                solver.add(Not(policy_logic_map[prev_pol]))
        
        check_result = solver.check()
        
        if check_result == sat:
            model = solver.model()
            new_row = {'Target_Policy_Name': target_policy}
            
            print(f"  Solved values:")
            
            # Map Z3 variables to template headers
            for header in required_headers:
                norm_header = normalize_var_name(header)
                
                matched = False
                for z3_var_name, z3_var in z3_vars.items():
                    if norm_header == z3_var_name or \
                       norm_header in z3_var_name or \
                       z3_var_name in norm_header:
                        
                        val = model[z3_var]
                        if val is not None:
                            try:
                                if is_int(z3_var):
                                    new_row[header] = val.as_long()
                                    print(f"    {header} = {new_row[header]}")
                                elif is_real(z3_var):
                                    new_row[header] = float(str(val))
                                    print(f"    {header} = {new_row[header]}")
                                elif is_string(z3_var):
                                    new_row[header] = str(val).strip('"')
                                    print(f"    {header} = {new_row[header]}")
                                else:
                                    new_row[header] = str(val)
                                    print(f"    {header} = {new_row[header]}")
                                matched = True
                                break
                            except:
                                pass
                
                if not matched:
                    new_row[header] = 0
            
            generated_rows.append(new_row)
            previous_policies.append(target_policy)
            print(f"  âœ… SUCCESS")
        
        else:
            print(f"  âŒ UNSAT (Cannot satisfy constraints)")
            previous_policies.append(target_policy)
    else:
        print(f"  âš ï¸  Not found in rules")

# 5. Export ==========================================================
print("\n" + "="*60)
print("Export Results")
print("="*60)

if generated_rows:
    final_df = pd.DataFrame(generated_rows)
    final_df.to_excel("Filled_Test_Data.xlsx", index=False)
    print(f"âœ… Generated {len(generated_rows)} test rows")
    print(f"ðŸ“„ Output: Filled_Test_Data.xlsx")
    
    # Show sample of generated data
    print("\nSample Generated Data:")
    for i, row in enumerate(generated_rows[:3], 1):
        print(f"\n  Row {i} - {row['Target_Policy_Name']}:")
        for key, val in list(row.items())[1:6]:  # Show first 5 columns
            print(f"    {key}: {val}")
else:
    print("âŒ No data generated")

print("\n" + "="*60)
print("COMPLETE")
print("="*60)
