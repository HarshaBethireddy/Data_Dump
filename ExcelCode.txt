def _extract_all_values(self, model, headers: List[str], target_policy: str, 
                       all_previous_policies: List[str]) -> Dict:
    """
    COMPLETE WATERFALL EXTRACTION with VERIFICATION:
    Extract values from Z3 model and VERIFY they make previous policies FALSE
    If not, adjust values to force them FALSE
    """
    row_data = {'Target_Policy': target_policy}

    # Get variables used by current policy
    current_policy_variables = self.vm.get_variables_for_policy(target_policy)
    
    # Get variables used by ALL previous policies
    all_previous_variables = set()
    for prev_policy in all_previous_policies:
        prev_vars = self.vm.get_variables_for_policy(prev_policy)
        all_previous_variables.update(prev_vars)
    
    # COMBINE: we want values for variables from BOTH current AND previous policies
    all_relevant_variables = current_policy_variables | all_previous_variables
    
    logger.debug(f"  [EXTRACT] Extracting values for {len(all_relevant_variables)} total variables")
    logger.debug(f"    - Current policy '{target_policy}' uses: {len(current_policy_variables)} variables")
    logger.debug(f"    - Previous {len(all_previous_policies)} policies use: {len(all_previous_variables)} variables")

    values_extracted = 0
    extracted_values = {}  # Store normalized_name -> value mapping

    # First pass: Extract all values from the model
    for header in headers:
        if header == 'Target_Policy':
            continue

        norm_header = self.vm.normalize_name(header)
        value = None

        # Check if this variable is relevant to current or previous policies
        if norm_header in all_relevant_variables:
            if norm_header in self.vm.variables:
                z3_var = self.vm.variables[norm_header]
                z3_val = model.eval(z3_var, model_completion=True)

                if z3_val is not None:
                    try:
                        if is_int(z3_val):
                            value = z3_val.as_long()
                        elif is_real(z3_val):
                            value = float(z3_val.as_decimal(10).replace('?', ''))
                        elif is_string_value(z3_val):
                            value = str(z3_val).strip('"')
                        else:
                            value = str(z3_val)
                            
                        values_extracted += 1
                        extracted_values[norm_header] = value
                        
                    except Exception as e:
                        logger.warning(f"    Error extracting value for {header}: {e}")
                        value = None

    # Second pass: VERIFY previous policies are FALSE and adjust if needed
    for prev_policy in all_previous_policies:
        if prev_policy not in self.policy_loader.policy_map:
            continue
            
        # Check if this previous policy evaluates to FALSE with current values
        is_false = self._verify_policy_false(prev_policy, extracted_values)
        
        if not is_false:
            logger.warning(f"    [FIX] Previous policy '{prev_policy}' is TRUE with current values - adjusting...")
            # Adjust values to make this policy FALSE
            extracted_values = self._force_policy_false(
                prev_policy, 
                extracted_values, 
                current_policy_variables  # Pass current policy vars to avoid conflicts
            )

    # Third pass: Populate row_data with final values
    for header in headers:
        if header == 'Target_Policy':
            continue

        norm_header = self.vm.normalize_name(header)
        
        if norm_header in extracted_values:
            row_data[header] = extracted_values[norm_header]
        else:
            row_data[header] = None

    logger.debug(f"  [EXTRACT] Successfully extracted {values_extracted} values")

    return row_data

def _verify_policy_false(self, policy_name: str, extracted_values: Dict) -> bool:
    """
    Verify that a policy evaluates to FALSE with given variable values
    Returns True if policy is FALSE, False if policy is TRUE
    """
    if policy_name not in self.policy_loader.policy_map:
        return True  # If policy doesn't exist, consider it "false"
    
    policy_expr = self.policy_loader.policy_map[policy_name]
    policy_vars = self.vm.get_variables_for_policy(policy_name)
    
    # Check if we have values for all variables in this policy
    has_all_values = all(var in extracted_values for var in policy_vars)
    
    if not has_all_values:
        # If we don't have all values, we can't verify - assume it needs fixing
        return False
    
    # Create a simple substitution to check if policy is satisfied
    # We'll use Z3 to evaluate the policy with the extracted values
    test_solver = Solver()
    test_solver.set("timeout", 1000)
    
    # Add the policy constraint
    test_solver.add(policy_expr)
    
    # Add all extracted values as constraints
    for norm_var, value in extracted_values.items():
        if norm_var in self.vm.variables:
            z3_var = self.vm.variables[norm_var]
            test_solver.add(z3_var == value)
    
    # Check if policy is satisfiable with these values
    result = test_solver.check()
    
    # If SAT, the policy is TRUE (bad - we want it FALSE)
    # If UNSAT, the policy is FALSE (good - this is what we want)
    return result == unsat

def _force_policy_false(self, policy_name: str, extracted_values: Dict, 
                       current_policy_vars: Set[str]) -> Dict:
    """
    Adjust variable values to force a policy to be FALSE
    CRITICAL: Don't modify variables used by the current policy
    Returns updated extracted_values dictionary
    """
    policy_vars = self.vm.get_variables_for_policy(policy_name)
    
    # Only adjust variables that are:
    # 1. Used by the previous policy we want to make FALSE
    # 2. NOT used by the current policy (to avoid breaking current policy)
    vars_to_adjust = policy_vars - current_policy_vars
    
    adjusted_values = extracted_values.copy()
    
    logger.debug(f"      Variables in policy '{policy_name}': {len(policy_vars)}")
    logger.debug(f"      Variables also in current policy: {len(policy_vars & current_policy_vars)}")
    logger.debug(f"      Variables to adjust: {len(vars_to_adjust)}")
    
    for norm_var in vars_to_adjust:
        if norm_var in self.vm.variables:
            var_type = self.vm.var_type_map.get(norm_var, 'int')
            
            # Use extreme values to violate constraints
            if var_type == 'int':
                adjusted_values[norm_var] = 9999
            elif var_type == 'real':
                adjusted_values[norm_var] = 9999.0
            elif var_type == 'string':
                adjusted_values[norm_var] = "INVALID_VALUE"
                
            logger.debug(f"        Set {norm_var} = {adjusted_values[norm_var]} to break policy")
    
    # If we couldn't adjust any variables (all are shared with current policy),
    # we need a different strategy: find a value that breaks the previous policy
    # without breaking the current policy
    if not vars_to_adjust:
        logger.debug(f"      All variables shared with current policy - using smart adjustment")
        adjusted_values = self._smart_adjust_shared_vars(
            policy_name, 
            adjusted_values, 
            current_policy_vars,
            policy_vars
        )
    
    return adjusted_values

def _smart_adjust_shared_vars(self, prev_policy_name: str, extracted_values: Dict,
                              current_policy_vars: Set[str], prev_policy_vars: Set[str]) -> Dict:
    """
    When all variables are shared between current and previous policy,
    find values that satisfy current policy but violate previous policy
    """
    # Get the policy expressions
    prev_policy_expr = self.policy_loader.policy_map[prev_policy_name]
    current_policy_expr = self.policy_loader.policy_map[self.current_target_policy]
    
    # The values we already have should satisfy current policy and violate previous
    # If they don't violate previous, there's a logical issue
    # But Z3 should have already ensured this with the NOT constraint
    
    # Just return the values as-is, since Z3's solution should already be correct
    logger.warning(f"      Cannot independently adjust - all variables shared. Trusting Z3 solution.")
    return extracted_values
Also add this to the OptimizedWaterfallGenerator class initialization:
def __init__(self, var_manager: Z3VariableManager, policy_loader: PolicyRuleLoader, 
             dependency_graph: PolicyDependencyGraph):
    self.vm = var_manager
    self.policy_loader = policy_loader
    self.dep_graph = dependency_graph
    self.solver = Solver()
    self.current_target_policy = None  # ADD THIS LINE
    self.generation_stats = {
        'total_policies': 0,
        'successful': 0,
        'unsat': 0,
        'unknown': 0,
        'skipped': 0,
        'avg_constraints_added': 0,
        'total_time': 0
    }
And update the generate method to set current_target_policy:
def generate(self, policy_order: List[str], template_headers: List[str]) -> pd.DataFrame:
    """Generate test data for policies in order with complete waterfall demonstration"""
    results = []
    previous_policies = {}
    total_constraints_added = 0

    # ... existing code ...

    for idx, policy_name in enumerate(policy_order, 1):
        policy_name = str(policy_name).strip()
        
        self.current_target_policy = policy_name  # ADD THIS LINE

        logger.info(f"\n[{idx}/{len(policy_order)}] Processing: {policy_name}")

        # ... rest of the existing code ...