import pandas as pd
import re
import ast
from z3 import *
from typing import Dict, Any, List, Set

# ==========================================
# CONFIGURATION (Your Hardcoded Paths)
# ==========================================
# Note: Use raw strings (r"...") to handle backslashes correctly
RULES_FILE      = r"C:\\Users\\C24692E\\Downloads\\PolicyArtifacts.xlsx"
# Assuming Order is in the same file based on your previous context, 
# but if it is separate, you can change this path:
ORDER_FILE      = r"C:\\Users\\C24692E\\Downloads\\PolicyArtifacts.xlsx" 
OUTPUT_TEMPLATE = r"C:\\Users\\C24692E\\Downloads\\input.xlsx"
OUTPUT_FILE     = "Filled_Test_Data.xlsx"

# ==========================================
# 1. THE ADVANCED AST PARSER
# ==========================================
class Z3RuleVisitor(ast.NodeVisitor):
    """
    Traverses a Python Abstract Syntax Tree (AST) to build Z3 constraints safely.
    Handles nested logic like ((A > 5) OR (B < 10)) automatically.
    """
    def __init__(self, generator):
        self.gen = generator

    def visit_constraint(self, node):
        if isinstance(node, ast.Module):
            return self.visit_constraint(node.body[0])
        elif isinstance(node, ast.Expr):
            return self.visit_constraint(node.value)
        elif isinstance(node, ast.BoolOp):
            values = [self.visit_constraint(v) for v in node.values]
            return And(values) if isinstance(node.op, ast.And) else Or(values)
        elif isinstance(node, ast.Compare):
            left = self.visit_constraint(node.left)
            right = self.visit_constraint(node.comparators[0])
            op = node.ops[0]
            
            if isinstance(op, ast.Gt): return left > right
            elif isinstance(op, ast.Lt): return left < right
            elif isinstance(op, ast.GtE): return left >= right
            elif isinstance(op, ast.LtE): return left <= right
            elif isinstance(op, ast.Eq): return left == right
            elif isinstance(op, ast.NotEq): return left != right
        elif isinstance(node, ast.Constant):
            val = node.value
            if isinstance(val, (int, float)):
                return RealVal(val) # Always use Real for numbers
            elif isinstance(val, str):
                # Check if this string matches a known column header
                clean_val = self.gen.normalize_header(val)
                if clean_val in self.gen.known_headers_map:
                    return self.gen.get_z3_var(clean_val)
                else:
                    return StringVal(val)
        raise ValueError(f"Unsupported logic structure: {type(node)}")

# ==========================================
# 2. THE GENERATOR ENGINE
# ==========================================
class PolicyDataGenerator:
    def __init__(self):
        self.z3_vars: Dict[str, Any] = {}
        self.policy_logic_map: Dict[str, Any] = {}
        self.solver = Solver()
        self.known_headers_map: Dict[str, str] = {} 

    def normalize_header(self, name: str) -> str:
        return str(name).strip().replace("'", "").replace('"', "")

    def _sanitize_z3_name(self, name: str) -> str:
        clean = re.sub(r'[^a-zA-Z0-9]', '_', name)
        return re.sub(r'_+', '_', clean).strip('_')

    def get_z3_var(self, name: str):
        norm_name = self.normalize_header(name)
        if norm_name in self.z3_vars:
            return self.z3_vars[norm_name]
        
        safe_name = self._sanitize_z3_name(norm_name)
        # Default to Real to support both Int and Float comparisons safely
        v = Real(safe_name) 
        self.z3_vars[norm_name] = v
        return v

    def parse_rule(self, rule_string):
        if pd.isna(rule_string): return None
        # Convert SQL style '=' to Python '=='
        clean_rule = str(rule_string).strip()
        clean_rule = re.sub(r'(?<![<>!])=(?!=)', '==', clean_rule)
        try:
            tree = ast.parse(clean_rule, mode='eval')
            return Z3RuleVisitor(self).visit_constraint(tree)
        except Exception as e:
            print(f"    [Warning] Could not parse rule: {clean_rule} ({e})")
            return None

    def load_context(self, template_path):
        print(f"1. Reading Template headers from: {template_path}")
        try:
            df = pd.read_excel(template_path)
            for col in df.columns:
                norm = self.normalize_header(col)
                self.known_headers_map[norm] = col # Store exact raw name
                self.get_z3_var(norm) # Pre-register as variable
        except Exception as e:
            print(f"Error reading template: {e}")
            exit(1)

    def load_rules(self, rules_path, order_path):
        print(f"2. Loading Rules/Order from: {rules_path}")
        try:
            xls = pd.ExcelFile(rules_path)
            
            # --- INTELLIGENT SHEET DETECTION ---
            # Try to find a sheet with "rule" in the name, otherwise use the first one
            rules_sheet = next((s for s in xls.sheet_names if "rule" in s.lower()), xls.sheet_names[0])
            
            # Try to find a sheet with "order" in the name
            # If your order is in a separate file, we read that file instead
            if rules_path != order_path:
                xls_order = pd.ExcelFile(order_path)
                order_sheet = next((s for s in xls_order.sheet_names if "order" in s.lower()), xls_order.sheet_names[0])
                rules_df = pd.read_excel(xls, sheet_name=rules_sheet)
                self.order_df = pd.read_excel(xls_order, sheet_name=order_sheet)
            else:
                # Same file logic
                order_sheet = next((s for s in xls.sheet_names if "order" in s.lower()), None)
                if not order_sheet:
                     # Fallback: assume 2nd sheet is order if not named explicitly
                    order_sheet = xls.sheet_names[1] if len(xls.sheet_names) > 1 else xls.sheet_names[0]
                
                rules_df = pd.read_excel(xls, sheet_name=rules_sheet)
                self.order_df = pd.read_excel(xls, sheet_name=order_sheet)
                
            print(f"   Using Rules Sheet: '{rules_sheet}'")
            print(f"   Using Order Sheet: '{order_sheet}'")

        except Exception as e:
            print(f"Error reading rules/order: {e}")
            exit(1)

        print("3. Compiling Rules...")
        current_policy = None
        current_exprs = []
        current_conjs = []

        for _, row in rules_df.iterrows():
            # Safe access to columns by index
            p_name = row.iloc[0]
            rule_def = row.iloc[1]
            conj = str(row.iloc[2]).strip().upper() if len(row) > 2 and pd.notna(row.iloc[2]) else 'AND'

            if pd.notna(p_name) and str(p_name).strip() != "":
                if current_policy:
                    self._save_policy(current_policy, current_exprs, current_conjs)
                current_policy = str(p_name).strip()
                current_exprs = []
                current_conjs = []

            if pd.notna(rule_def):
                z3_expr = self.parse_rule(rule_def)
                if z3_expr is not None:
                    current_exprs.append(z3_expr)
                    current_conjs.append(conj)

        if current_policy:
            self._save_policy(current_policy, current_exprs, current_conjs)

    def _save_policy(self, name, exprs, conjs):
        if not exprs: return
        combined = exprs[0]
        for i in range(1, len(exprs)):
            if conjs[i-1] == 'OR': combined = Or(combined, exprs[i])
            else: combined = And(combined, exprs[i])
        self.policy_logic_map[name] = combined

    def generate(self):
        print("\n4. Solving (Incremental Waterfall)...")
        generated_rows = []
        
        for idx, row in self.order_df.iterrows():
            target = str(row.iloc[0]).strip()
            if target not in self.policy_logic_map:
                print(f"   [Skip] Policy '{target}' not found in rules")
                continue

            print(f"   [{idx+1}] Solving for: {target}...", end=" ")
            
            self.solver.push() # Snapshot
            self.solver.add(self.policy_logic_map[target])
            
            if self.solver.check() == sat:
                print("SAT ✓")
                model = self.solver.model()
                row_data = {'Target_Policy_Name': target}
                
                for norm, z3_var in self.z3_vars.items():
                    raw = self.known_headers_map.get(norm, norm)
                    val = model[z3_var]
                    if val is not None:
                        if is_real(val):
                            row_data[raw] = float(val.as_decimal(10).replace('?', ''))
                        elif is_string(val):
                            row_data[raw] = val.as_string()
                    else:
                        row_data[raw] = 0 # Default value
                
                generated_rows.append(row_data)
            else:
                print("UNSAT ✗ (Contradiction)")

            self.solver.pop() # Restore
            # Waterfall: Permanently negate this policy for future rows
            self.solver.add(Not(self.policy_logic_map[target]))

        return pd.DataFrame(generated_rows)

# ==========================================
# MAIN EXECUTION
# ==========================================
if __name__ == "__main__":
    gen = PolicyDataGenerator()
    
    # 1. Load Headers (so we know what is a variable vs string)
    gen.load_context(OUTPUT_TEMPLATE)
    
    # 2. Load Rules
    gen.load_rules(RULES_FILE, ORDER_FILE)
    
    # 3. Solve
    df_result = gen.generate()
    
    # 4. Export
    if not df_result.empty:
        # Use openpyxl for auto-width formatting
        with pd.ExcelWriter(OUTPUT_FILE, engine="openpyxl") as writer:
            df_result.to_excel(writer, index=False)
            ws = writer.sheets['Sheet1']
            for column in ws.columns:
                length = max(len(str(cell.value)) for cell in column)
                ws.column_dimensions[column[0].column_letter].width = min(length + 2, 60)
        print(f"\n✅ DONE. Generated {len(df_result)} rows in '{OUTPUT_FILE}'")
    else:
        print("\n❌ NO DATA GENERATED.")
